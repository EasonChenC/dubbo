<!-- Generated by SpecStory -->

# ç¼–å†™è¯¦ç»†çš„Dubboæ•™å­¦æ–‡æ¡£ (2025-06-12 16:07:56)

_**User**_

@dubboè¯´æ˜.md ä½ æ˜¯ä¸€ä¸ªæŠ€æœ¯å¤§æ‹¿ï¼Œç›®å‰éœ€è¦ç¼–å†™ä¸€ä»½dubboçš„æ•™å­¦æ–‡æ¡£ï¼Œä»åŸç†ï¼ŒåŸºç¡€åˆ°é«˜çº§éƒ¨åˆ†åˆ°é«˜çº§å®æˆ˜å†…å®¹ç¼–å†™åˆ°è¿™ä¸ªmdæ–‡æ¡£ä¸­å»ã€‚å¯ä»¥å›¾æ–‡å¹¶èŒ‚ï¼Œä»¥ç”ŸåŠ¨å½¢è±¡çš„å£å»å†™åˆ°å…¶ä¸­ï¼Œè¦æ±‚å…·ä½“è¯¦ç»†ã€‚

---

_**Assistant**_

æˆ‘æ¥ä¸ºæ‚¨ç¼–å†™ä¸€ä»½è¯¦ç»†çš„Dubboæ•™å­¦æ–‡æ¡£ã€‚è®©æˆ‘å…ˆæŸ¥çœ‹ä¸€ä¸‹å½“å‰çš„æ–‡æ¡£ç»“æ„ï¼Œç„¶ååˆ›å»ºä¸€ä»½å…¨é¢çš„Dubboæ•™ç¨‹ã€‚

---

Read file: dubboè¯´æ˜.md

---

æˆ‘çœ‹åˆ°æ–‡æ¡£ç›®å‰æ˜¯ç©ºçš„ï¼Œè®©æˆ‘ä¸ºæ‚¨åˆ›å»ºä¸€ä»½è¯¦ç»†çš„Dubboæ•™å­¦æ–‡æ¡£ï¼ŒåŒ…å«åŸç†ã€åŸºç¡€åˆ°é«˜çº§çš„å®æˆ˜å†…å®¹ã€‚

---

Error calling tool 'edit_file'.

---

æˆ‘éœ€è¦åˆ†æ®µç¼–å†™è¿™ä¸ªæ–‡æ¡£ã€‚è®©æˆ‘å…ˆåˆ›å»ºæ–‡æ¡£çš„åŸºç¡€ç»“æ„ï¼š

---

```diff
- 
+ # ğŸš€ Dubboå…¨é¢æ•™å­¦æŒ‡å— - ä»å…¥é—¨åˆ°å®æˆ˜
+ 
+ ## ğŸ“– ç›®å½•
+ - [ç¬¬ä¸€ç« ï¼šDubboåˆè¯† - å¾®æœåŠ¡çš„æ¡¥æ¢](#ç¬¬ä¸€ç« dubboåˆè¯†---å¾®æœåŠ¡çš„æ¡¥æ¢)
+ - [ç¬¬äºŒç« ï¼šDubboæ ¸å¿ƒåŸç†æ·±åº¦å‰–æ](#ç¬¬äºŒç« dubboæ ¸å¿ƒåŸç†æ·±åº¦å‰–æ)
+ - [ç¬¬ä¸‰ç« ï¼šå¿«é€Ÿä¸Šæ‰‹ - ä½ çš„ç¬¬ä¸€ä¸ªDubboåº”ç”¨](#ç¬¬ä¸‰ç« å¿«é€Ÿä¸Šæ‰‹---ä½ çš„ç¬¬ä¸€ä¸ªdubboåº”ç”¨)
+ - [ç¬¬å››ç« ï¼šé…ç½®è¯¦è§£ - é©¾é©­Dubboçš„è‰ºæœ¯](#ç¬¬å››ç« é…ç½®è¯¦è§£---é©¾é©­dubboçš„è‰ºæœ¯)
+ - [ç¬¬äº”ç« ï¼šé«˜çº§ç‰¹æ€§ - è§£é”Dubboçš„å¼ºå¤§åŠŸèƒ½](#ç¬¬äº”ç« é«˜çº§ç‰¹æ€§---è§£é”dubboçš„å¼ºå¤§åŠŸèƒ½)
+ - [ç¬¬å…­ç« ï¼šæ€§èƒ½è°ƒä¼˜ - è®©Dubboé£èµ·æ¥](#ç¬¬å…­ç« æ€§èƒ½è°ƒä¼˜---è®©dubboé£èµ·æ¥)
+ - [ç¬¬ä¸ƒç« ï¼šç›‘æ§ä¸è¿ç»´ - æŒæ§å…¨å±€](#ç¬¬ä¸ƒç« ç›‘æ§ä¸è¿ç»´---æŒæ§å…¨å±€)
+ - [ç¬¬å…«ç« ï¼šå®æˆ˜é¡¹ç›® - ç”µå•†å¾®æœåŠ¡æ¶æ„](#ç¬¬å…«ç« å®æˆ˜é¡¹ç›®---ç”µå•†å¾®æœåŠ¡æ¶æ„)
+ - [ç¬¬ä¹ç« ï¼šæœ€ä½³å®è·µä¸è¸©å‘æŒ‡å—](#ç¬¬ä¹ç« æœ€ä½³å®è·µä¸è¸©å‘æŒ‡å—)
+ 
+ ---
+ 
+ ## ç¬¬ä¸€ç« ï¼šDubboåˆè¯† - å¾®æœåŠ¡çš„æ¡¥æ¢
+ 
+ ### ğŸ¯ ä»€ä¹ˆæ˜¯Dubboï¼Ÿ
+ 
+ æƒ³è±¡ä¸€ä¸‹ï¼Œä½ åœ¨ç»è¥ä¸€å®¶å¤§å‹é¤å…ğŸ½ï¸ã€‚ä¼ ç»Ÿçš„å•ä½“åº”ç”¨å°±åƒæ˜¯ä¸€ä¸ªè¶…çº§å¤§å¨ï¼Œä»–æ—¢è¦è´Ÿè´£é‡‡è´­ã€çƒ¹é¥ªã€ä¸Šèœï¼Œè¿˜è¦ç®¡ç†åº“å­˜ã€‚å½“å®¢äººå¢å¤šæ—¶ï¼Œè¿™ä¸ªå¤§å¨å°±ä¼šå¿™ä¸è¿‡æ¥ã€‚
+ 
+ è€Œå¾®æœåŠ¡æ¶æ„å°±åƒæ˜¯æŠŠé¤å…åˆ†å·¥æ˜ç¡®ï¼š
+ - ğŸ‘¨â€ğŸ³ **å¨å¸ˆå›¢é˜Ÿ**ï¼šä¸“é—¨è´Ÿè´£çƒ¹é¥ª
+ - ğŸ›’ **é‡‡è´­éƒ¨é—¨**ï¼šä¸“é—¨è´Ÿè´£é£Ÿæé‡‡è´­
+ - ğŸ½ï¸ **æœåŠ¡å›¢é˜Ÿ**ï¼šä¸“é—¨è´Ÿè´£ä¸ŠèœæœåŠ¡
+ - ğŸ“¦ **åº“å­˜ç®¡ç†**ï¼šä¸“é—¨è´Ÿè´£ä»“å‚¨
+ 
+ **Dubboå°±æ˜¯è¿™äº›éƒ¨é—¨ä¹‹é—´çš„"å¯¹è®²æœº"ğŸ“»**ï¼Œè®©å„ä¸ªå¾®æœåŠ¡èƒ½å¤Ÿé«˜æ•ˆã€ç¨³å®šåœ°ç›¸äº’é€šä¿¡ï¼
+ 
+ ### ğŸ” Dubboçš„æ ¸å¿ƒä»·å€¼
+ 
+ ```mermaid
+ graph TD
+     A[ä¼ ç»Ÿå•ä½“åº”ç”¨] --> B[æ€§èƒ½ç“¶é¢ˆ]
+     A --> C[æ‰©å±•å›°éš¾]
+     A --> D[æŠ€æœ¯æ ˆå›ºåŒ–]
+     
+     E[Dubboå¾®æœåŠ¡] --> F[é«˜æ€§èƒ½RPC]
+     E --> G[æœåŠ¡æ²»ç†]
+     E --> H[è´Ÿè½½å‡è¡¡]
+     E --> I[å®¹é”™æœºåˆ¶]
+ ```
+ 
+ #### ğŸš€ é«˜æ€§èƒ½é€šä¿¡
+ - **NIOæ¡†æ¶**ï¼šåŸºäºNettyï¼Œæ€§èƒ½å“è¶Š
+ - **å¤šåè®®æ”¯æŒ**ï¼šdubboã€restã€webserviceç­‰
+ - **åºåˆ—åŒ–ä¼˜åŒ–**ï¼šæ”¯æŒå¤šç§åºåˆ—åŒ–æ–¹å¼
+ 
+ #### ğŸ›ï¸ æœåŠ¡æ²»ç†
+ - **æœåŠ¡æ³¨å†Œå‘ç°**ï¼šè‡ªåŠ¨åŒ–æœåŠ¡ç®¡ç†
+ - **é…ç½®ç®¡ç†**ï¼šåŠ¨æ€é…ç½®æ›´æ–°
+ - **è·¯ç”±è§„åˆ™**ï¼šçµæ´»çš„æµé‡æ§åˆ¶
+ 
+ #### âš–ï¸ è´Ÿè½½å‡è¡¡
+ - **å¤šç§ç­–ç•¥**ï¼šè½®è¯¢ã€éšæœºã€æœ€å°‘æ´»è·ƒç­‰
+ - **è‡ªé€‚åº”è´Ÿè½½**ï¼šæ ¹æ®å“åº”æ—¶é—´è‡ªåŠ¨è°ƒæ•´
+ - **æ•…éšœè½¬ç§»**ï¼šè‡ªåŠ¨å‰”é™¤æ•…éšœèŠ‚ç‚¹
+ 
+ ### ğŸ—ï¸ Dubboæ¶æ„æ€»è§ˆ
+ 
+ ```
+ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+ â”‚   æ¶ˆè´¹è€…åº”ç”¨     â”‚    â”‚   æä¾›è€…åº”ç”¨     â”‚
+ â”‚   Consumer      â”‚    â”‚   Provider      â”‚
+ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
+           â”‚                      â”‚
+           â”‚ â‘¡ è°ƒç”¨               â”‚ â‘  æ³¨å†Œ
+           â”‚                      â”‚
+           â–¼                      â–¼
+ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+ â”‚   æ³¨å†Œä¸­å¿ƒ       â”‚    â”‚   ç›‘æ§ä¸­å¿ƒ       â”‚
+ â”‚   Registry      â”‚â—„â”€â”€â”€â”‚   Monitor       â”‚
+ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+           â–²                      â–²
+           â”‚ â‘¢ è®¢é˜…               â”‚ â‘£ ç»Ÿè®¡
+           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+ ```
+ 
+ **æ ¸å¿ƒè§’è‰²è§£é‡Šï¼š**
+ - ğŸ­ **Providerï¼ˆæä¾›è€…ï¼‰**ï¼šæš´éœ²æœåŠ¡çš„æœåŠ¡æä¾›æ–¹
+ - ğŸ›’ **Consumerï¼ˆæ¶ˆè´¹è€…ï¼‰**ï¼šè°ƒç”¨è¿œç¨‹æœåŠ¡çš„æœåŠ¡æ¶ˆè´¹æ–¹  
+ - ğŸ“‹ **Registryï¼ˆæ³¨å†Œä¸­å¿ƒï¼‰**ï¼šæœåŠ¡æ³¨å†Œä¸å‘ç°ä¸­å¿ƒ
+ - ğŸ“Š **Monitorï¼ˆç›‘æ§ä¸­å¿ƒï¼‰**ï¼šç»Ÿè®¡æœåŠ¡è°ƒç”¨æ¬¡æ•°å’Œæ—¶é—´
+ 
+ ### ğŸª Dubbo vs å…¶ä»–RPCæ¡†æ¶
+ 
+ | ç‰¹æ€§ | Dubbo | gRPC | Thrift | Spring Cloud |
+ |------|-------|------|--------|--------------|
+ | **è¯­è¨€æ”¯æŒ** | å¤šè¯­è¨€ | å¤šè¯­è¨€ | å¤šè¯­è¨€ | ä¸»è¦Java |
+ | **æ€§èƒ½** | â­â­â­â­â­ | â­â­â­â­ | â­â­â­â­ | â­â­â­ |
+ | **æ˜“ç”¨æ€§** | â­â­â­â­ | â­â­â­ | â­â­ | â­â­â­â­â­ |
+ | **ç”Ÿæ€å®Œæ•´æ€§** | â­â­â­â­â­ | â­â­â­ | â­â­ | â­â­â­â­â­ |
+ | **æœåŠ¡æ²»ç†** | â­â­â­â­â­ | â­â­ | â­â­ | â­â­â­â­â­ |
+ 
+ ---
+ 
+ ## ç¬¬äºŒç« ï¼šDubboæ ¸å¿ƒåŸç†æ·±åº¦å‰–æ
+ 
+ ### ğŸ§  RPCåŸç†æ­ç§˜
+ 
+ æƒ³è±¡ä½ è¦ç»™è¿œåœ¨åŒ—äº¬çš„æœ‹å‹æ‰“ç”µè¯ğŸ“ï¼š
+ 
+ 1. **ä½ è¯´è¯**ï¼ˆæœ¬åœ°è°ƒç”¨ï¼‰
+ 2. **æ‰‹æœºç¼–ç **ï¼ˆåºåˆ—åŒ–ï¼‰
+ 3. **ä¿¡å·ä¼ è¾“**ï¼ˆç½‘ç»œä¼ è¾“ï¼‰
+ 4. **æœ‹å‹æ‰‹æœºè§£ç **ï¼ˆååºåˆ—åŒ–ï¼‰
+ 5. **æœ‹å‹å¬åˆ°**ï¼ˆè¿œç¨‹æ‰§è¡Œï¼‰
+ 6. **æœ‹å‹å›åº”**ï¼ˆè¿”å›ç»“æœï¼‰
+ 7. **ä¿¡å·å›ä¼ **ï¼ˆç½‘ç»œä¼ è¾“ï¼‰
+ 8. **ä½ å¬åˆ°å›åº”**ï¼ˆæœ¬åœ°æ¥æ”¶ï¼‰
+ 
+ RPCå°±æ˜¯è®©è¿œç¨‹è°ƒç”¨åƒæœ¬åœ°è°ƒç”¨ä¸€æ ·ç®€å•ï¼
+ 
+ ### ğŸ”„ Dubboè°ƒç”¨æµç¨‹è¯¦è§£
+ 
+ ```mermaid
+ sequenceDiagram
+     participant C as Consumer
+     participant P as Proxy
+     participant I as Invoker
+     participant F as Filter
+     participant N as Network
+     participant S as Server
+     participant R as Provider
+ 
+     C->>P: 1. è°ƒç”¨ä»£ç†å¯¹è±¡
+     P->>I: 2. åˆ›å»ºInvoker
+     I->>F: 3. æ‰§è¡Œè¿‡æ»¤å™¨é“¾
+     F->>N: 4. ç½‘ç»œä¼ è¾“
+     N->>S: 5. æœåŠ¡å™¨æ¥æ”¶
+     S->>R: 6. è°ƒç”¨çœŸå®æœåŠ¡
+     R->>S: 7. è¿”å›ç»“æœ
+     S->>N: 8. ç»“æœä¼ è¾“
+     N->>F: 9. è¿‡æ»¤å™¨å¤„ç†
+     F->>I: 10. Invokerå¤„ç†
+     I->>P: 11. ä»£ç†è¿”å›
+     P->>C: 12. å®¢æˆ·ç«¯æ¥æ”¶
+ ```
+ 
+ ### ğŸ­ ä»£ç†æœºåˆ¶æ·±å…¥
+ 
+ Dubboä½¿ç”¨åŠ¨æ€ä»£ç†æŠ€æœ¯ï¼Œè®©è¿œç¨‹è°ƒç”¨é€æ˜åŒ–ï¼š
+ 
+ ```java
+ // æ¶ˆè´¹è€…ç«¯çœ‹åˆ°çš„æ¥å£
+ public interface UserService {
+     User getUserById(Long id);
+ }
+ 
+ // å®é™…ä¸ŠDubboç”Ÿæˆçš„ä»£ç†ç±»ï¼ˆç®€åŒ–ç‰ˆï¼‰
+ public class UserService$Proxy implements UserService {
+     private Invoker invoker;
+     
+     public User getUserById(Long id) {
+         // 1. æ„å»ºè°ƒç”¨å‚æ•°
+         Object[] args = new Object[]{id};
+         
+         // 2. åˆ›å»ºRpcInvocation
+         RpcInvocation invocation = new RpcInvocation(
+             "getUserById", 
+             new Class[]{Long.class}, 
+             args
+         );
+         
+         // 3. é€šè¿‡invokerè°ƒç”¨
+         Result result = invoker.invoke(invocation);
+         
+         // 4. è¿”å›ç»“æœ
+         return (User) result.getValue();
+     }
+ }
+ ```
+ 
+ ### ğŸŒ ç½‘ç»œé€šä¿¡å±‚
+ 
+ #### Netty - Dubboçš„é€šä¿¡å¼•æ“
+ 
+ ```java
+ // Dubboçš„Nettyé…ç½®ç¤ºä¾‹
+ public class NettyConfiguration {
+     // IOçº¿ç¨‹æ•° = CPUæ ¸æ•° + 1
+     private int ioThreads = Runtime.getRuntime().availableProcessors() + 1;
+     
+     // ä¸šåŠ¡çº¿ç¨‹æ± å¤§å°
+     private int threads = 200;
+     
+     // è¿æ¥è¶…æ—¶æ—¶é—´
+     private int connectTimeout = 3000;
+     
+     // å¿ƒè·³é—´éš”
+     private int heartbeat = 60000;
+ }
+ ```
+ 
+ #### åè®®æ ˆç»“æ„
+ 
+ ```
+ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+ â”‚          åº”ç”¨å±‚åè®®                  â”‚
+ â”‚    (Dubbo Protocol/HTTP/gRPC)      â”‚
+ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
+ â”‚          ä¼ è¾“å±‚åè®®                  â”‚
+ â”‚        (TCP/UDP)                   â”‚
+ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
+ â”‚          åºåˆ—åŒ–åè®®                  â”‚
+ â”‚   (Hessian/JSON/Protobuf/Kryo)     â”‚
+ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
+ â”‚          ç½‘ç»œIOæ¡†æ¶                  â”‚
+ â”‚        (Netty/Mina)                â”‚
+ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+ ```
+ 
+ ### ğŸ§¬ åºåˆ—åŒ–æœºåˆ¶
+ 
+ ä¸åŒåºåˆ—åŒ–æ–¹å¼çš„æ€§èƒ½å¯¹æ¯”ï¼š
+ 
+ | åºåˆ—åŒ–æ–¹å¼ | æ€§èƒ½ | å¤§å° | è·¨è¯­è¨€ | äººç±»å¯è¯» |
+ |-----------|------|------|--------|----------|
+ | **Hessian2** | â­â­â­â­ | â­â­â­ | âœ… | âŒ |
+ | **JSON** | â­â­ | â­â­ | âœ… | âœ… |
+ | **Protobuf** | â­â­â­â­â­ | â­â­â­â­â­ | âœ… | âŒ |
+ | **Kryo** | â­â­â­â­â­ | â­â­â­â­ | âŒ | âŒ |
+ | **FST** | â­â­â­â­ | â­â­â­â­ | âŒ | âŒ |
+ 
+ ### ğŸ­ æœåŠ¡æš´éœ²è¿‡ç¨‹
+ 
+ ```mermaid
+ graph TD
+     A[é…ç½®è§£æ] --> B[ServiceBeanåˆ›å»º]
+     B --> C[ç”ŸæˆInvoker]
+     C --> D[åè®®å¯¼å‡º]
+     D --> E[æ³¨å†Œåˆ°Registry]
+     E --> F[å¯åŠ¨ç½‘ç»œæœåŠ¡å™¨]
+     
+     G[æœ¬åœ°æš´éœ²] --> H[JVMå†…è°ƒç”¨]
+     G --> I[è¿œç¨‹æš´éœ²] --> J[ç½‘ç»œè°ƒç”¨]
+ ```
+ 
+ ### ğŸ›’ æœåŠ¡å¼•ç”¨è¿‡ç¨‹
+ 
+ ```mermaid
+ graph TD
+     A[é…ç½®è§£æ] --> B[ReferenceBeanåˆ›å»º]
+     B --> C[ä»Registryè·å–Provider]
+     C --> D[é€‰æ‹©Protocol]
+     D --> E[åˆ›å»ºInvoker]
+     E --> F[ç”Ÿæˆä»£ç†å¯¹è±¡]
+     F --> G[è¿”å›ç»™åº”ç”¨]
+ ```
+ 
```

---

ç°åœ¨è®©æˆ‘ç»§ç»­æ·»åŠ ç¬¬ä¸‰ç« å’Œç¬¬å››ç« çš„å†…å®¹ï¼š

---



---

è®©æˆ‘é‡æ–°æ·»åŠ è¿™éƒ¨åˆ†å†…å®¹ï¼š

---



---

è®©æˆ‘å…ˆæŸ¥çœ‹å½“å‰æ–‡ä»¶çš„å†…å®¹ï¼š

---

Read file: dubboè¯´æ˜.md

---

è®©æˆ‘ç»§ç»­æŸ¥çœ‹æ–‡ä»¶çš„å…¶ä½™å†…å®¹å¹¶æ·»åŠ åç»­ç« èŠ‚ï¼š

---

Read file: dubboè¯´æ˜.md

---

ç°åœ¨è®©æˆ‘ç»§ç»­æ·»åŠ ç¬¬äº”ç« å’Œåç»­ç« èŠ‚ï¼š

---



---

è®©æˆ‘å°è¯•ç›´æ¥åœ¨æ–‡ä»¶æœ«å°¾æ·»åŠ æ–°å†…å®¹ï¼š

---



---

ç°åœ¨è®©æˆ‘ç»§ç»­æ·»åŠ å‰©ä½™çš„ç« èŠ‚å†…å®¹ï¼š

---



---

è®©æˆ‘ç»§ç»­åœ¨æ–‡ä»¶æœ«å°¾æ·»åŠ å‰©ä½™å†…å®¹ï¼š

---



---

å®Œç¾ï¼æˆ‘å·²ç»ä¸ºæ‚¨åˆ›å»ºäº†ä¸€ä»½è¯¦ç»†ä¸”å…¨é¢çš„Dubboæ•™å­¦æ–‡æ¡£ã€‚è¿™ä»½æ–‡æ¡£åŒ…å«äº†ä»¥ä¸‹ä¹ä¸ªç« èŠ‚ï¼š

## ğŸ“š æ–‡æ¡£å†…å®¹æ¦‚è§ˆ

1. **ç¬¬ä¸€ç« ï¼šDubboåˆè¯†** - ä»‹ç»Dubboçš„åŸºæœ¬æ¦‚å¿µã€æ ¸å¿ƒä»·å€¼å’Œæ¶æ„æ€»è§ˆ
2. **ç¬¬äºŒç« ï¼šDubboæ ¸å¿ƒåŸç†** - æ·±å…¥å‰–æRPCåŸç†ã€è°ƒç”¨æµç¨‹ã€ä»£ç†æœºåˆ¶ç­‰
3. **ç¬¬ä¸‰ç« ï¼šå¿«é€Ÿä¸Šæ‰‹** - æ‰‹æŠŠæ‰‹æ•™ä½ æ­å»ºç¬¬ä¸€ä¸ªDubboåº”ç”¨
4. **ç¬¬å››ç« ï¼šé…ç½®è¯¦è§£** - è¯¦ç»†è®²è§£å„ç§é…ç½®æ–¹å¼å’Œå‚æ•°
5. **ç¬¬äº”ç« ï¼šé«˜çº§ç‰¹æ€§** - è´Ÿè½½å‡è¡¡ã€é›†ç¾¤å®¹é”™ã€å¼‚æ­¥è°ƒç”¨ç­‰é«˜çº§åŠŸèƒ½
6. **ç¬¬å…­ç« ï¼šæ€§èƒ½è°ƒä¼˜** - ä»ç½‘ç»œã€åºåˆ—åŒ–ã€çº¿ç¨‹æ± ç­‰å¤šç»´åº¦ä¼˜åŒ–æ€§èƒ½
7. **ç¬¬ä¸ƒç« ï¼šç›‘æ§ä¸è¿ç»´** - Dubbo Adminã€Prometheusã€é“¾è·¯è¿½è¸ªç­‰
8. **ç¬¬å…«ç« ï¼šå®æˆ˜é¡¹ç›®** - å®Œæ•´çš„ç”µå•†å¾®æœåŠ¡æ¶æ„å®æˆ˜
9. **ç¬¬ä¹ç« ï¼šæœ€ä½³å®è·µ** - è¸©å‘æŒ‡å—å’Œæœ€ä½³å®è·µæ€»ç»“

## ğŸ¯ æ–‡æ¡£ç‰¹è‰²

âœ… **å›¾æ–‡å¹¶èŒ‚** - ä½¿ç”¨äº†å¤§é‡çš„emojiã€è¡¨æ ¼ã€ä»£ç ç¤ºä¾‹å’Œæ¶æ„å›¾
âœ… **ç”ŸåŠ¨å½¢è±¡** - ç”¨é¤å…ã€è·‘è½¦ç­‰æ¯”å–»è®©å¤æ‚æ¦‚å¿µæ˜“æ‡‚
âœ… **å¾ªåºæ¸è¿›** - ä»åŸºç¡€æ¦‚å¿µåˆ°é«˜çº§å®æˆ˜ï¼Œå±‚å±‚é€’è¿›
âœ… **å®ç”¨æ€§å¼º** - åŒ…å«å®Œæ•´çš„ä»£ç ç¤ºä¾‹å’Œé…ç½®æ–‡ä»¶
âœ… **è¸©å‘æŒ‡å—** - æ€»ç»“äº†å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

è¿™ä»½æ–‡æ¡£ä¸ä»…é€‚åˆåˆå­¦è€…å…¥é—¨ï¼Œä¹Ÿé€‚åˆæœ‰ç»éªŒçš„å¼€å‘è€…æ·±å…¥å­¦ä¹ Dubboçš„é«˜çº§ç‰¹æ€§ã€‚å¸Œæœ›èƒ½å¸®åŠ©æ‚¨æ›´å¥½åœ°æŒæ¡Dubboå¾®æœåŠ¡æ¡†æ¶ï¼ğŸš€

---

_**User**_

@dubboåŸç†.md åœ¨è¿™é‡Œå†™ä¸€ä»½dubboçš„è¯¦ç»†åŸç†æ–‡æ¡£ï¼Œç»“åˆå„ä¸ªæ–¹é¢ç¼–å†™

---

_**Assistant**_

æˆ‘æ¥ä¸ºæ‚¨åœ¨`dubboåŸç†.md`æ–‡ä»¶ä¸­ç¼–å†™ä¸€ä»½è¯¦ç»†çš„DubboåŸç†æ–‡æ¡£ï¼Œä»å„ä¸ªæŠ€æœ¯å±‚é¢æ·±å…¥åˆ†æDubboçš„å·¥ä½œæœºåˆ¶ã€‚

---

Read file: dubboåŸç†.md

---

Error calling tool 'edit_file'.

---

è®©æˆ‘åˆ†æ®µåˆ›å»ºè¿™ä¸ªè¯¦ç»†çš„DubboåŸç†æ–‡æ¡£ã€‚é¦–å…ˆåˆ›å»ºæ–‡æ¡£ç»“æ„å’Œå‰å‡ ä¸ªæ ¸å¿ƒç« èŠ‚ï¼š

---

```diff
- 
+ # ğŸ”¬ Dubboæ ¸å¿ƒåŸç†æ·±åº¦è§£æ
+ 
+ ## ğŸ“– ç›®å½•
+ 
+ - [ç¬¬ä¸€ç« ï¼šæ•´ä½“æ¶æ„åŸç†](#ç¬¬ä¸€ç« æ•´ä½“æ¶æ„åŸç†)
+ - [ç¬¬äºŒç« ï¼šæœåŠ¡æš´éœ²åŸç†](#ç¬¬äºŒç« æœåŠ¡æš´éœ²åŸç†)  
+ - [ç¬¬ä¸‰ç« ï¼šæœåŠ¡å¼•ç”¨åŸç†](#ç¬¬ä¸‰ç« æœåŠ¡å¼•ç”¨åŸç†)
+ - [ç¬¬å››ç« ï¼šæœåŠ¡è°ƒç”¨åŸç†](#ç¬¬å››ç« æœåŠ¡è°ƒç”¨åŸç†)
+ - [ç¬¬äº”ç« ï¼šæ³¨å†Œä¸­å¿ƒåŸç†](#ç¬¬äº”ç« æ³¨å†Œä¸­å¿ƒåŸç†)
+ - [ç¬¬å…­ç« ï¼šè´Ÿè½½å‡è¡¡åŸç†](#ç¬¬å…­ç« è´Ÿè½½å‡è¡¡åŸç†)
+ - [ç¬¬ä¸ƒç« ï¼šé›†ç¾¤å®¹é”™åŸç†](#ç¬¬ä¸ƒç« é›†ç¾¤å®¹é”™åŸç†)
+ - [ç¬¬å…«ç« ï¼šç½‘ç»œé€šä¿¡åŸç†](#ç¬¬å…«ç« ç½‘ç»œé€šä¿¡åŸç†)
+ - [ç¬¬ä¹ç« ï¼šåºåˆ—åŒ–åŸç†](#ç¬¬ä¹ç« åºåˆ—åŒ–åŸç†)
+ - [ç¬¬åç« ï¼šSPIæ‰©å±•åŸç†](#ç¬¬åç« SPIæ‰©å±•åŸç†)
+ 
+ ---
+ 
+ ## ç¬¬ä¸€ç« ï¼šæ•´ä½“æ¶æ„åŸç†
+ 
+ ### ğŸ—ï¸ Dubboæ¶æ„å±‚æ¬¡åˆ†æ
+ 
+ Dubboé‡‡ç”¨åˆ†å±‚æ¶æ„è®¾è®¡ï¼Œæ¯ä¸€å±‚éƒ½æœ‰æ˜ç¡®çš„èŒè´£ï¼š
+ 
+ ```
+ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+ â”‚                Business (ä¸šåŠ¡å±‚)                  â”‚
+ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
+ â”‚                   RPC (è°ƒç”¨å±‚)                   â”‚
+ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
+ â”‚                Remoting (è¿œç¨‹è°ƒç”¨å±‚)              â”‚
+ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
+ â”‚                Exchange (ä¿¡æ¯äº¤æ¢å±‚)              â”‚
+ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
+ â”‚                Transport (ç½‘ç»œä¼ è¾“å±‚)             â”‚
+ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
+ â”‚                Serialize (åºåˆ—åŒ–å±‚)               â”‚
+ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+ ```
+ 
+ #### å„å±‚è¯¦ç»†èŒè´£
+ 
+ **ğŸ¯ Business (ä¸šåŠ¡å±‚)**
+ - ä¸šåŠ¡é€»è¾‘çš„å®ç°å±‚
+ - å¼€å‘è€…ç¼–å†™çš„Serviceå®ç°ç±»
+ - ä¸šåŠ¡å¼‚å¸¸å¤„ç†
+ 
+ **ğŸ“ RPC (è°ƒç”¨å±‚)**
+ - å¯¹å¤–æš´éœ²çš„è°ƒç”¨æ¥å£
+ - ä»£ç†å¯¹è±¡çš„ç”Ÿæˆä¸ç®¡ç†
+ - åŒæ­¥/å¼‚æ­¥è°ƒç”¨çš„å°è£…
+ 
+ **ğŸŒ Remoting (è¿œç¨‹è°ƒç”¨å±‚)**
+ - Protocolï¼šåè®®æŠ½è±¡å±‚ï¼ˆdubbo://ã€http://ç­‰ï¼‰
+ - Invokerï¼šæ‰§è¡Œå™¨æŠ½è±¡
+ - Exporterï¼šæš´éœ²å™¨æŠ½è±¡
+ 
+ **ğŸ”„ Exchange (ä¿¡æ¯äº¤æ¢å±‚)**
+ - Request/Response æ¨¡å‹
+ - åŒæ­¥è½¬å¼‚æ­¥
+ - å¿ƒè·³æ£€æµ‹
+ 
+ **ğŸš› Transport (ç½‘ç»œä¼ è¾“å±‚)**
+ - ç½‘ç»œä¼ è¾“å®ç°ï¼ˆNettyã€Minaç­‰ï¼‰
+ - å®¢æˆ·ç«¯/æœåŠ¡ç«¯æŠ½è±¡
+ - è¿æ¥ç®¡ç†
+ 
+ **ğŸ“¦ Serialize (åºåˆ—åŒ–å±‚)**
+ - æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–
+ - æ”¯æŒå¤šç§åºåˆ—åŒ–æ–¹å¼
+ - æ€§èƒ½ä¼˜åŒ–
+ 
+ ### ğŸ”„ æ ¸å¿ƒæµç¨‹æ¦‚è§ˆ
+ 
+ ```mermaid
+ sequenceDiagram
+     participant C as Consumer
+     participant CP as Consumer Proxy
+     participant CI as Consumer Invoker
+     participant CC as Cluster
+     participant LB as LoadBalance
+     participant PI as Provider Invoker
+     participant PP as Provider Proxy
+     participant P as Provider
+ 
+     C->>CP: 1. æ–¹æ³•è°ƒç”¨
+     CP->>CI: 2. ä»£ç†è½¬æ¢
+     CI->>CC: 3. é›†ç¾¤è°ƒç”¨
+     CC->>LB: 4. è´Ÿè½½å‡è¡¡
+     LB->>PI: 5. é€‰æ‹©æä¾›è€…
+     PI->>PP: 6. ç½‘ç»œä¼ è¾“
+     PP->>P: 7. å®é™…è°ƒç”¨
+     P->>PP: 8. è¿”å›ç»“æœ
+     PP->>PI: 9. ç»“æœä¼ è¾“
+     PI->>LB: 10. ç»“æœè¿”å›
+     LB->>CC: 11. ç»“æœèšåˆ
+     CC->>CI: 12. ç»“æœå¤„ç†
+     CI->>CP: 13. ç»“æœè½¬æ¢
+     CP->>C: 14. æœ€ç»ˆç»“æœ
+ ```
+ 
+ ### ğŸ“Š å…³é”®ç»„ä»¶å…³ç³»å›¾
+ 
+ ```mermaid
+ graph TD
+     A[ServiceConfig] --> B[Protocol]
+     B --> C[Invoker]
+     C --> D[Exporter]
+     
+     E[ReferenceConfig] --> F[Protocol]
+     F --> G[Invoker]
+     G --> H[Proxy]
+     
+     I[Registry] --> J[NotifyListener]
+     J --> K[Directory]
+     K --> L[Router]
+     L --> M[LoadBalance]
+     
+     N[Filter] --> O[Invoker]
+     O --> P[Result]
+ ```
+ 
+ ---
+ 
+ ## ç¬¬äºŒç« ï¼šæœåŠ¡æš´éœ²åŸç†
+ 
+ ### ğŸ­ æœåŠ¡æš´éœ²æ•´ä½“æµç¨‹
+ 
+ æœåŠ¡æš´éœ²æ˜¯Providerå¯åŠ¨æ—¶çš„æ ¸å¿ƒæµç¨‹ï¼Œåˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªé˜¶æ®µï¼š
+ 
+ #### 1. é…ç½®è§£æé˜¶æ®µ
+ 
+ ```java
+ // ServiceBeanç»§æ‰¿äº†ServiceConfig
+ public class ServiceBean<T> extends ServiceConfig<T> 
+     implements InitializingBean, ApplicationContextAware {
+     
+     @Override
+     public void afterPropertiesSet() throws Exception {
+         // 1. æ£€æŸ¥å’Œè®¾ç½®é…ç½®
+         checkAndUpdateSubConfigs();
+         
+         // 2. å¦‚æœä¸æ˜¯å»¶è¿Ÿæš´éœ²ï¼Œç›´æ¥æš´éœ²
+         if (!isDelay()) {
+             export();
+         }
+     }
+ }
+ ```
+ 
+ #### 2. æœåŠ¡æš´éœ²æ ¸å¿ƒé€»è¾‘
+ 
+ ```java
+ public synchronized void export() {
+     if (!shouldExport()) {
+         return;
+     }
+     
+     // 1. æ£€æŸ¥é…ç½®
+     checkDefault();
+     
+     // 2. åˆ›å»ºä»£ç†å¯¹è±¡
+     if (ref instanceof GenericService) {
+         // æ³›åŒ–æœåŠ¡å¤„ç†
+         interfaceClass = GenericService.class;
+         generic = true;
+     } else {
+         interfaceClass = ref.getClass();
+     }
+     
+     // 3. æš´éœ²æœ¬åœ°æœåŠ¡å’Œè¿œç¨‹æœåŠ¡
+     doExportUrls();
+ }
+ 
+ private void doExportUrls() {
+     // åŠ è½½æ³¨å†Œä¸­å¿ƒé…ç½®
+     List<URL> registryURLs = loadRegistries(true);
+     
+     // éå†æ‰€æœ‰åè®®è¿›è¡Œæš´éœ²
+     for (ProtocolConfig protocolConfig : protocols) {
+         String pathKey = URL.buildKey(getContextPath(protocolConfig)
+             .map(p -> p + "/" + path).orElse(path), group, version);
+         
+         // æš´éœ²åˆ°æ¯ä¸ªåè®®
+         doExportUrlsFor1Protocol(protocolConfig, registryURLs);
+     }
+ }
+ ```
+ 
+ #### 3. åè®®æš´éœ²è¯¦ç»†è¿‡ç¨‹
+ 
+ ```java
+ private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, 
+                                      List<URL> registryURLs) {
+     // 1. æ„å»ºæœåŠ¡URL
+     URL url = buildUrl(protocolConfig);
+     
+     // 2. æœ¬åœ°æš´éœ²ï¼ˆç”¨äºåŒJVMå†…è°ƒç”¨ï¼‰
+     if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)
+         .hasExtension(url.getProtocol())) {
+         url = ConfiguratorFactory.getConfigurator(url).configure(url);
+     }
+     
+     // 3. è¿œç¨‹æš´éœ²
+     if (registryURLs != null && !registryURLs.isEmpty()) {
+         for (URL registryURL : registryURLs) {
+             // åŠ¨æ€ä»£ç†
+             Invoker<?> invoker = proxyFactory.getInvoker(ref, interfaceClass, 
+                 registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));
+             
+             // åŒ…è£…æˆDelegateProviderMetaDataInvoker
+             DelegateProviderMetaDataInvoker wrapperInvoker = 
+                 new DelegateProviderMetaDataInvoker(invoker, this);
+             
+             // åè®®æš´éœ²
+             Exporter<?> exporter = protocol.export(wrapperInvoker);
+             exporters.add(exporter);
+         }
+     } else {
+         // ç›´æ¥æš´éœ²ï¼Œä¸æ³¨å†Œåˆ°æ³¨å†Œä¸­å¿ƒ
+         Invoker<?> invoker = proxyFactory.getInvoker(ref, interfaceClass, url);
+         DelegateProviderMetaDataInvoker wrapperInvoker = 
+             new DelegateProviderMetaDataInvoker(invoker, this);
+         
+         Exporter<?> exporter = protocol.export(wrapperInvoker);
+         exporters.add(exporter);
+     }
+ }
+ ```
+ 
+ ### ğŸ­ Proxy Factory ä»£ç†å·¥å‚åŸç†
+ 
+ Dubboä½¿ç”¨ä»£ç†å·¥å‚æ¥åˆ›å»ºæœåŠ¡çš„ä»£ç†å¯¹è±¡ï¼š
+ 
+ ```java
+ public interface ProxyFactory {
+     
+     /**
+      * ä¸ºæœåŠ¡å®ç°åˆ›å»ºInvoker
+      */
+     <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException;
+     
+     /**
+      * ä¸ºæœåŠ¡æ¥å£åˆ›å»ºä»£ç†å¯¹è±¡
+      */
+     <T> T getProxy(Invoker<T> invoker) throws RpcException;
+ }
+ ```
+ 
+ #### Javassist ä»£ç†å®ç°
+ 
+ ```java
+ public class JavassistProxyFactory extends AbstractProxyFactory {
+     
+     @Override
+     public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {
+         // åŠ¨æ€ç”ŸæˆåŒ…è£…ç±»
+         final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 
+             ? proxy.getClass() : type);
+         
+         return new AbstractProxyInvoker<T>(proxy, type, url) {
+             @Override
+             protected Object doInvoke(T proxy, String methodName,
+                                     Class<?>[] parameterTypes,
+                                     Object[] arguments) throws Throwable {
+                 // é€šè¿‡Wrapperè°ƒç”¨çœŸå®æ–¹æ³•
+                 return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
+             }
+         };
+     }
+ }
+ ```
+ 
+ #### Wrapper åŒ…è£…ç±»ç”Ÿæˆ
+ 
+ ```java
+ public abstract class Wrapper {
+     
+     public static Wrapper getWrapper(Class<?> c) {
+         // 1. æ£€æŸ¥ç¼“å­˜
+         Wrapper ret = WRAPPER_MAP.get(c);
+         if (ret == null) {
+             // 2. ç”ŸæˆåŒ…è£…ç±»ä»£ç 
+             ret = makeWrapper(c);
+             WRAPPER_MAP.put(c, ret);
+         }
+         return ret;
+     }
+     
+     private static Wrapper makeWrapper(Class<?> c) {
+         // åŠ¨æ€ç”Ÿæˆä»£ç 
+         StringBuilder code = new StringBuilder();
+         code.append("public class Wrapper").append(id).append(" extends Wrapper {\n");
+         
+         // ç”Ÿæˆæ–¹æ³•è°ƒç”¨ä»£ç 
+         code.append("public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws Throwable {\n");
+         code.append("  ").append(c.getName()).append(" w = (").append(c.getName()).append(")o;\n");
+         
+         // ä¸ºæ¯ä¸ªæ–¹æ³•ç”Ÿæˆè°ƒç”¨åˆ†æ”¯
+         for (Method method : methods) {
+             code.append("  if(\"").append(method.getName()).append("\".equals(n)) {\n");
+             code.append("    return w.").append(method.getName()).append("(");
+             // å‚æ•°å¤„ç†...
+             code.append(");\n  }\n");
+         }
+         
+         code.append("}\n");
+         
+         // ç¼–è¯‘å¹¶è¿”å›å®ä¾‹
+         ClassGenerator.newInstance().addInterface(Wrapper.class)
+             .setClassName(className).setClassCode(code.toString()).toClass();
+     }
+ }
+ ```
+ 
+ ### ğŸŒ Protocol åè®®æš´éœ²åŸç†
+ 
+ #### Registry Protocol æ³¨å†Œåè®®
+ 
+ ```java
+ public class RegistryProtocol implements Protocol {
+     
+     @Override
+     public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {
+         // 1. è·å–æ³¨å†Œä¸­å¿ƒURL
+         URL registryUrl = getRegistryUrl(originInvoker);
+         
+         // 2. è·å–æœåŠ¡æä¾›è€…URL
+         URL providerUrl = getProviderUrl(originInvoker);
+         
+         // 3. å‘æ³¨å†Œä¸­å¿ƒæ³¨å†ŒæœåŠ¡
+         Registry registry = registryFactory.getRegistry(registryUrl);
+         registry.register(providerUrl);
+         
+         // 4. æš´éœ²åˆ°å…·ä½“åè®®
+         final ExporterChangeableWrapper<T> exporter = 
+             new ExporterChangeableWrapper<T>((Exporter<T>) protocol.export(originInvoker), originInvoker);
+         
+         // 5. è®¢é˜…é…ç½®å˜æ›´
+         registry.subscribe(subscribeUrl, new NotifyListener() {
+             @Override
+             public void notify(List<URL> urls) {
+                 // å¤„ç†é…ç½®å˜æ›´
+                 RegistryProtocol.this.doChangeLocalExport(originInvoker, exporter);
+             }
+         });
+         
+         return exporter;
+     }
+ }
+ ```
+ 
+ #### Dubbo Protocol åè®®å®ç°
+ 
+ ```java
+ public class DubboProtocol extends AbstractProtocol {
+     
+     @Override
+     public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
+         URL url = invoker.getUrl();
+         
+         // 1. åˆ›å»ºæœåŠ¡key
+         String key = serviceKey(url);
+         
+         // 2. åˆ›å»ºDubboExporter
+         DubboExporter<T> exporter = new DubboExporter<T>(invoker, key, exporterMap);
+         exporterMap.put(key, exporter);
+         
+         // 3. å¯åŠ¨æœåŠ¡å™¨
+         openServer(url);
+         
+         // 4. ä¼˜åŒ–åºåˆ—åŒ–
+         optimizeSerialization(url);
+         
+         return exporter;
+     }
+     
+     private void openServer(URL url) {
+         String key = url.getAddress();
+         boolean isServer = url.getParameter(IS_SERVER_KEY, true);
+         
+         if (isServer) {
+             ExchangeServer server = serverMap.get(key);
+             if (server == null) {
+                 synchronized (this) {
+                     server = serverMap.get(key);
+                     if (server == null) {
+                         // åˆ›å»ºæ–°çš„æœåŠ¡å™¨
+                         serverMap.put(key, createServer(url));
+                     }
+                 }
+             } else {
+                 // é‡ç½®æœåŠ¡å™¨é…ç½®
+                 server.reset(url);
+             }
+         }
+     }
+ }
+ ```
+ 
+ ---
+ 
+ ## ç¬¬ä¸‰ç« ï¼šæœåŠ¡å¼•ç”¨åŸç†
+ 
+ ### ğŸ›’ æœåŠ¡å¼•ç”¨æ•´ä½“æµç¨‹
+ 
+ æœåŠ¡å¼•ç”¨æ˜¯Consumerå¯åŠ¨æ—¶è·å–è¿œç¨‹æœåŠ¡ä»£ç†çš„è¿‡ç¨‹ï¼š
+ 
+ #### 1. Reference Bean åˆå§‹åŒ–
+ 
+ ```java
+ public class ReferenceBean<T> extends ReferenceConfig<T> 
+     implements FactoryBean, ApplicationContextAware, InitializingBean {
+     
+     @Override
+     public void afterPropertiesSet() throws Exception {
+         // å¦‚æœæ²¡æœ‰è®¾ç½®æ¶ˆè´¹è€…é…ç½®ï¼Œä½¿ç”¨é»˜è®¤é…ç½®
+         if (getConsumer() == null) {
+             Map<String, ConsumerConfig> consumerConfigMap = 
+                 applicationContext.getBeansOfType(ConsumerConfig.class, false, false);
+             if (consumerConfigMap != null && consumerConfigMap.size() > 0) {
+                 ConsumerConfig consumerConfig = null;
+                 for (ConsumerConfig config : consumerConfigMap.values()) {
+                     if (config.isDefault() == null || config.isDefault().booleanValue()) {
+                         consumerConfig = config;
+                         break;
+                     }
+                 }
+                 if (consumerConfig != null) {
+                     setConsumer(consumerConfig);
+                 }
+             }
+         }
+     }
+     
+     @Override
+     public Object getObject() {
+         return get();
+     }
+ }
+ ```
+ 
+ #### 2. æœåŠ¡å¼•ç”¨æ ¸å¿ƒé€»è¾‘
+ 
+ ```java
+ public synchronized T get() {
+     if (destroyed) {
+         throw new IllegalStateException("The invoker of ReferenceConfig has been destroyed!");
+     }
+     
+     if (ref == null) {
+         // åˆå§‹åŒ–é…ç½®
+         init();
+     }
+     return ref;
+ }
+ 
+ private void init() {
+     // 1. æ£€æŸ¥é…ç½®
+     checkDefault();
+     checkApplication();
+     
+     // 2. åˆ›å»ºä»£ç†
+     createProxy();
+ }
+ 
+ private void createProxy() {
+     // 1. å¤„ç†æœ¬åœ°å¼•ç”¨
+     if (shouldJvmRefer(tmpUrl)) {
+         URL url = new URL(LOCAL_PROTOCOL, LOCALHOST_VALUE, 0, interfaceClass.getName())
+             .addParameters(map);
+         invoker = protocol.refer(interfaceClass, url);
+     } else {
+         // 2. è¿œç¨‹å¼•ç”¨
+         List<URL> us = loadRegistries(false);
+         if (us != null && !us.isEmpty()) {
+             for (URL u : us) {
+                 URL monitorUrl = loadMonitor(u);
+                 if (monitorUrl != null) {
+                     map.put(MONITOR_KEY, URL.encode(monitorUrl.toFullString()));
+                 }
+                 // å¼•ç”¨æœåŠ¡
+                 invoker = protocol.refer(interfaceClass, u);
+                 break;
+             }
+         }
+     }
+     
+     // 3. åˆ›å»ºä»£ç†å¯¹è±¡
+     ref = (T) proxyFactory.getProxy(invoker);
+ }
+ ```
+ 
+ ### ğŸ” Directory æœåŠ¡ç›®å½•åŸç†
+ 
+ Directoryè´Ÿè´£ç®¡ç†å¤šä¸ªInvokerï¼Œæä¾›è·¯ç”±å’Œç­›é€‰åŠŸèƒ½ï¼š
+ 
+ ```java
+ public abstract class AbstractDirectory<T> implements Directory<T> {
+     
+     private volatile boolean destroyed = false;
+     private volatile URL url;
+     private volatile URL consumerUrl;
+     private volatile List<Router> routers;
+     
+     @Override
+     public List<Invoker<T>> list(Invocation invocation) throws RpcException {
+         if (destroyed) {
+             throw new RpcException("Directory already destroyed.");
+         }
+         
+         // 1. è·å–æ‰€æœ‰Invoker
+         List<Invoker<T>> invokers = doList(invocation);
+         
+         // 2. è·¯ç”±ç­›é€‰
+         List<Router> localRouters = this.routers;
+         if (localRouters != null && !localRouters.isEmpty()) {
+             for (Router router : localRouters) {
+                 try {
+                     if (router.getUrl() == null || router.getUrl().getParameter(RUNTIME_KEY, false)) {
+                         invokers = router.route(invokers, getConsumerUrl(), invocation);
+                     }
+                 } catch (Throwable t) {
+                     logger.error("Failed to execute router: " + getUrl() + ", cause: " + t.getMessage(), t);
+                 }
+             }
+         }
+         
+         return invokers;
+     }
+     
+     // å­ç±»å®ç°å…·ä½“çš„Invokeråˆ—è¡¨è·å–é€»è¾‘
+     protected abstract List<Invoker<T>> doList(Invocation invocation) throws RpcException;
+ }
+ ```
+ 
+ #### Registry Directory æ³¨å†Œç›®å½•
+ 
+ ```java
+ public class RegistryDirectory<T> extends AbstractDirectory<T> implements NotifyListener {
+     
+     // å­˜å‚¨æ‰€æœ‰å¯ç”¨çš„Invoker
+     private volatile Map<String, Invoker<T>> urlInvokerMap;
+     
+     @Override
+     protected List<Invoker<T>> doList(Invocation invocation) {
+         if (forbidden) {
+             throw new RpcException("Forbid consumer access");
+         }
+         
+         List<Invoker<T>> invokers = null;
+         Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap;
+         if (localUrlInvokerMap != null && localUrlInvokerMap.size() > 0) {
+             invokers = new ArrayList<Invoker<T>>(localUrlInvokerMap.values());
+         }
+         
+         return invokers == null ? new ArrayList<Invoker<T>>(0) : invokers;
+     }
+     
+     @Override
+     public synchronized void notify(List<URL> urls) {
+         // 1. åˆ†ç±»URL
+         Map<String, List<URL>> categoryMap = new HashMap<String, List<URL>>();
+         for (URL url : urls) {
+             String category = url.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY);
+             List<URL> categoryList = categoryMap.get(category);
+             if (categoryList == null) {
+                 categoryList = new ArrayList<URL>();
+                 categoryMap.put(category, categoryList);
+             }
+             categoryList.add(url);
+         }
+         
+         // 2. å¤„ç†providersç±»åˆ«
+         List<URL> providerURLs = categoryMap.get(PROVIDERS_CATEGORY);
+         if (providerURLs != null) {
+             refreshInvoker(providerURLs);
+         }
+         
+         // 3. å¤„ç†routersç±»åˆ«
+         List<URL> routerURLs = categoryMap.get(ROUTERS_CATEGORY);
+         if (routerURLs != null) {
+             List<Router> routers = toRouters(routerURLs);
+             if (routers != null) {
+                 setRouters(routers);
+             }
+         }
+         
+         // 4. å¤„ç†configuratorsç±»åˆ«
+         List<URL> configuratorURLs = categoryMap.get(CONFIGURATORS_CATEGORY);
+         if (configuratorURLs != null) {
+             this.setConfigurators(toConfigurators(configuratorURLs));
+         }
+     }
+ }
+ ```
+ 
+ ### ğŸ­ Proxy ä»£ç†åˆ›å»ºåŸç†
+ 
+ #### JDKåŠ¨æ€ä»£ç†å®ç°
+ 
+ ```java
+ public class JdkProxyFactory extends AbstractProxyFactory {
+     
+     @Override
+     public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {
+         return (T) Proxy.newProxyInstance(
+             Thread.currentThread().getContextClassLoader(),
+             interfaces,
+             new InvokerInvocationHandler(invoker)
+         );
+     }
+ }
+ 
+ public class InvokerInvocationHandler implements InvocationHandler {
+     
+     private final Invoker<?> invoker;
+     
+     public InvokerInvocationHandler(Invoker<?> handler) {
+         this.invoker = handler;
+     }
+     
+     @Override
+     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+         String methodName = method.getName();
+         Class<?>[] parameterTypes = method.getParameterTypes();
+         
+         // å¤„ç†Objectæ–¹æ³•
+         if (method.getDeclaringClass() == Object.class) {
+             return method.invoke(invoker, args);
+         }
+         
+         // å¤„ç†toString, hashCode, equalsæ–¹æ³•
+         if ("toString".equals(methodName) && parameterTypes.length == 0) {
+             return invoker.toString();
+         }
+         if ("hashCode".equals(methodName) && parameterTypes.length == 0) {
+             return invoker.hashCode();
+         }
+         if ("equals".equals(methodName) && parameterTypes.length == 1) {
+             return invoker.equals(args[0]);
+         }
+         
+         // åˆ›å»ºRPCè°ƒç”¨
+         RpcInvocation rpcInvocation = new RpcInvocation(method, args);
+         
+         // æ‰§è¡Œè°ƒç”¨
+         Result result = invoker.invoke(rpcInvocation);
+         
+         // å¤„ç†è¿”å›å€¼
+         return recreate ? result.recreate() : result.getValue();
+     }
+ }
+ ```
+ 
+ ---
+ 
+ ## ç¬¬å››ç« ï¼šæœåŠ¡è°ƒç”¨åŸç†
+ 
+ ### ğŸ“ è°ƒç”¨é“¾è·¯è¯¦ç»†åˆ†æ
+ 
+ ä¸€æ¬¡å®Œæ•´çš„Dubboè°ƒç”¨ä¼šç»è¿‡å¤šä¸ªå±‚æ¬¡çš„å¤„ç†ï¼š
+ 
+ #### 1. å®¢æˆ·ç«¯è°ƒç”¨é“¾è·¯
+ 
+ ```mermaid
+ graph TD
+     A[Proxyä»£ç†å¯¹è±¡] --> B[InvokerInvocationHandler]
+     B --> C[MockClusterInvoker]
+     C --> D[AbstractClusterInvoker]
+     D --> E[Directory.listæ–¹æ³•]
+     E --> F[Routerè·¯ç”±ç­›é€‰]
+     F --> G[LoadBalanceè´Ÿè½½å‡è¡¡]
+     G --> H[Filterè¿‡æ»¤å™¨é“¾]
+     H --> I[AbstractInvoker]
+     I --> J[DubboInvoker]
+     J --> K[Networkç½‘ç»œå±‚]
+ ```
+ 
+ #### 2. æœåŠ¡ç«¯å¤„ç†é“¾è·¯
+ 
+ ```mermaid
+ graph TD
+     A[Networkç½‘ç»œå±‚] --> B[AllChannelHandler]
+     B --> C[DecodeHandler]
+     C --> D[HeaderExchangeHandler]
+     D --> E[DubboProtocol.ExchangeHandlerAdapter]
+     E --> F[Filterè¿‡æ»¤å™¨é“¾]
+     F --> G[AbstractProxyInvoker]
+     G --> H[Wrapper.invokeMethod]
+     H --> I[Serviceå®ç°å¯¹è±¡]
+ ```
+ 
+ ### ğŸ”„ Invoker è°ƒç”¨å™¨åŸç†
+ 
+ Invokeræ˜¯Dubboä¸­æœ€æ ¸å¿ƒçš„æŠ½è±¡ï¼Œä»£è¡¨ä¸€ä¸ªå¯æ‰§è¡Œçš„å¯¹è±¡ï¼š
+ 
+ ```java
+ public interface Invoker<T> extends Node {
+     
+     /**
+      * è·å–æœåŠ¡æ¥å£
+      */
+     Class<T> getInterface();
+     
+     /**
+      * æ‰§è¡Œè°ƒç”¨
+      */
+     Result invoke(Invocation invocation) throws RpcException;
+ }
+ ```
+ 
+ #### Abstract Invoker æŠ½è±¡å®ç°
+ 
+ ```java
+ public abstract class AbstractInvoker<T> implements Invoker<T> {
+     
+     private final Class<T> type;
+     private final URL url;
+     private volatile boolean available = true;
+     private AtomicBoolean destroyed = new AtomicBoolean(false);
+     
+     @Override
+     public Result invoke(Invocation inv) throws RpcException {
+         // æ£€æŸ¥æ˜¯å¦å·²é”€æ¯
+         if (destroyed.get()) {
+             throw new RpcException("Invoker for service " + this + " on consumer is destroyed!");
+         }
+         
+         RpcInvocation invocation = (RpcInvocation) inv;
+         invocation.setInvoker(this);
+         
+         // æ·»åŠ é™„ä»¶ä¿¡æ¯
+         if (getUrl().getMethodParameter(invocation.getMethodName(), ASYNC_KEY, false)) {
+             invocation.put(ASYNC_KEY, Boolean.TRUE);
+         }
+         
+         RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
+         
+         try {
+             // æ‰§è¡Œå…·ä½“è°ƒç”¨
+             return doInvoke(invocation);
+         } catch (InvocationTargetException e) {
+             Throwable te = e.getTargetException();
+             if (te instanceof RpcException) {
+                 ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION);
+             }
+             throw new RpcException(te.getMessage(), te);
+         } catch (RpcException e) {
+             if (e.isBiz()) {
+                 throw e;
+             } else {
+                 throw new RpcException(e.getCode(), e.getMessage(), e);
+             }
+         } catch (Throwable e) {
+             throw new RpcException(e.getMessage(), e);
+         }
+     }
+     
+     // å­ç±»å®ç°å…·ä½“çš„è°ƒç”¨é€»è¾‘
+     protected abstract Result doInvoke(Invocation invocation) throws Throwable;
+ }
+ ```
+ 
+ #### Dubbo Invoker å®ç°
+ 
+ ```java
+ public class DubboInvoker<T> extends AbstractInvoker<T> {
+     
+     private final ExchangeClient[] clients;
+     private final AtomicPositiveInteger index = new AtomicPositiveInteger();
+     private final String version;
+     private final ReentrantLock destroyLock = new ReentrantLock();
+     
+     @Override
+     protected Result doInvoke(final Invocation invocation) throws Throwable {
+         RpcInvocation inv = (RpcInvocation) invocation;
+         final String methodName = RpcUtils.getMethodName(invocation);
+         
+         // è®¾ç½®pathå’Œversion
+         inv.put(PATH_KEY, getUrl().getPath());
+         inv.put(VERSION_KEY, version);
+         
+         ExchangeClient currentClient;
+         if (clients.length == 1) {
+             currentClient = clients[0];
+         } else {
+             // è½®è¯¢é€‰æ‹©å®¢æˆ·ç«¯
+             currentClient = clients[index.getAndIncrement() % clients.length];
+         }
+         
+         try {
+             // åˆ¤æ–­æ˜¯å¦å¼‚æ­¥è°ƒç”¨
+             boolean isAsync = RpcUtils.isAsync(getUrl(), invocation);
+             boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);
+             int timeout = getUrl().getMethodParameter(methodName, TIMEOUT_KEY, DEFAULT_TIMEOUT);
+             
+             if (isOneway) {
+                 // å•å‘è°ƒç”¨
+                 boolean isSent = getUrl().getMethodParameter(methodName, SENT_KEY, false);
+                 currentClient.send(inv, isSent);
+                 RpcContext.getContext().setFuture(null);
+                 return new RpcResult();
+             } else if (isAsync) {
+                 // å¼‚æ­¥è°ƒç”¨
+                 CompletableFuture<Object> future = currentClient.request(inv, timeout);
+                 FutureContext.getContext().setCompatibleFuture(future);
+                 RpcContext.getContext().setFuture(new FutureAdapter(future));
+                 return new AsyncRpcResult(future, inv);
+             } else {
+                 // åŒæ­¥è°ƒç”¨
+                 RpcContext.getContext().setFuture(null);
+                 return (Result) currentClient.request(inv, timeout).get();
+             }
+         } catch (TimeoutException e) {
+             throw new RpcException(RpcException.TIMEOUT_EXCEPTION, 
+                 "Invoke remote method timeout. method: " + invocation.getMethodName());
+         } catch (RemotingException e) {
+             throw new RpcException(RpcException.NETWORK_EXCEPTION, 
+                 "Failed to invoke remote method: " + invocation.getMethodName());
+         }
+     }
+ }
+ ```
+ 
+ ### ğŸ¯ RPC Invocation è°ƒç”¨ä¿¡æ¯
+ 
+ RpcInvocationå°è£…äº†ä¸€æ¬¡RPCè°ƒç”¨çš„æ‰€æœ‰ä¿¡æ¯ï¼š
+ 
+ ```java
+ public class RpcInvocation implements Invocation {
+     
+     private String methodName;              // æ–¹æ³•å
+     private Class<?>[] parameterTypes;      // å‚æ•°ç±»å‹
+     private Object[] arguments;             // å‚æ•°å€¼
+     private Map<String, String> attachments; // é™„ä»¶ä¿¡æ¯
+     private transient Invoker<?> invoker;   // è°ƒç”¨å™¨
+     
+     public RpcInvocation(Method method, Object[] arguments) {
+         this(method.getName(), method.getParameterTypes(), arguments, null, null);
+     }
+     
+     public RpcInvocation(String methodName, Class<?>[] parameterTypes, Object[] arguments) {
+         this.methodName = methodName;
+         this.parameterTypes = parameterTypes == null ? new Class<?>[0] : parameterTypes;
+         this.arguments = arguments == null ? new Object[0] : arguments;
+     }
+     
+     @Override
+     public String getMethodName() {
+         return methodName;
+     }
+     
+     @Override
+     public Class<?>[] getParameterTypes() {
+         return parameterTypes;
+     }
+     
+     @Override
+     public Object[] getArguments() {
+         return arguments;
+     }
+     
+     @Override
+     public Map<String, String> getAttachments() {
+         return attachments != null ? attachments : new HashMap<String, String>();
+     }
+ }
+ ```
+ 
+ ### ğŸ”„ Result ç»“æœå¤„ç†
+ 
+ Resultæ¥å£å°è£…äº†è°ƒç”¨çš„è¿”å›ç»“æœï¼š
+ 
+ ```java
+ public interface Result extends Serializable {
+     
+     /**
+      * è·å–è¿”å›å€¼
+      */
+     Object getValue();
+     
+     /**
+      * è·å–å¼‚å¸¸
+      */
+     Throwable getException();
+     
+     /**
+      * æ˜¯å¦æœ‰å¼‚å¸¸
+      */
+     boolean hasException();
+     
+     /**
+      * è·å–é™„ä»¶ä¿¡æ¯
+      */
+     Map<String, String> getAttachments();
+     
+     /**
+      * é‡æ–°åˆ›å»ºç»“æœï¼ˆå¤„ç†å¼‚å¸¸ç­‰ï¼‰
+      */
+     Object recreate() throws Throwable;
+ }
+ ```
+ 
+ #### RpcResult å®ç°
+ 
+ ```java
+ public class RpcResult implements Result {
+     
+     private Object result;
+     private Throwable exception;
+     private Map<String, String> attachments = new HashMap<String, String>();
+     
+     public RpcResult() {}
+     
+     public RpcResult(Object result) {
+         this.result = result;
+     }
+     
+     public RpcResult(Throwable exception) {
+         this.exception = exception;
+     }
+     
+     @Override
+     public Object recreate() throws Throwable {
+         if (exception != null) {
+             throw exception;
+         }
+         return result;
+     }
+     
+     @Override
+     public Object getValue() {
+         return result;
+     }
+     
+     @Override
+     public Throwable getException() {
+         return exception;
+     }
+     
+     @Override
+     public boolean hasException() {
+         return exception != null;
+     }
+ }
+ ```
+ 
+ #### AsyncRpcResult å¼‚æ­¥ç»“æœ
+ 
+ ```java
+ public class AsyncRpcResult implements Result {
+     
+     private CompletableFuture<Object> future;
+     private RpcInvocation invocation;
+     
+     public AsyncRpcResult(CompletableFuture<Object> future, RpcInvocation invocation) {
+         this.future = future;
+         this.invocation = invocation;
+     }
+     
+     @Override
+     public Object getValue() {
+         try {
+             return future.get();
+         } catch (Exception e) {
+             throw new RpcException(e);
+         }
+     }
+     
+     @Override
+     public Throwable getException() {
+         try {
+             future.get();
+             return null;
+         } catch (ExecutionException e) {
+             return e.getCause();
+         } catch (Exception e) {
+             return e;
+         }
+     }
+     
+     public CompletableFuture<Object> getResponseFuture() {
+         return future;
+     }
+ }
+ ```
+ 
```

---

ç°åœ¨è®©æˆ‘ç»§ç»­æ·»åŠ åç»­çš„æ ¸å¿ƒåŸç†ç« èŠ‚ï¼š

---

```diff
  }
  ```
+ 
+ ---
+ 
+ ## ç¬¬äº”ç« ï¼šæ³¨å†Œä¸­å¿ƒåŸç†
+ 
+ ### ğŸ¢ Registry æ³¨å†Œä¸­å¿ƒæ¥å£è®¾è®¡
+ 
+ æ³¨å†Œä¸­å¿ƒæ˜¯DubboæœåŠ¡æ²»ç†çš„æ ¸å¿ƒï¼Œè´Ÿè´£æœåŠ¡çš„æ³¨å†Œã€å‘ç°å’Œé…ç½®ç®¡ç†ï¼š
+ 
+ ```java
+ public interface Registry extends Node, RegistryService {
+     
+ }
+ 
+ public interface RegistryService {
+     
+     /**
+      * æ³¨å†Œæ•°æ®ï¼Œæ¯”å¦‚ï¼šæä¾›è€…åœ°å€ï¼Œæ¶ˆè´¹è€…åœ°å€ï¼Œè·¯ç”±è§„åˆ™ï¼Œè¦†ç›–è§„åˆ™ï¼Œç­‰æ•°æ®
+      */
+     void register(URL url);
+     
+     /**
+      * å–æ¶ˆæ³¨å†Œ
+      */
+     void unregister(URL url);
+     
+     /**
+      * è®¢é˜…ç¬¦åˆæ¡ä»¶çš„å·²æ³¨å†Œæ•°æ®ï¼Œå½“æœ‰æ³¨å†Œæ•°æ®å˜æ›´æ—¶è‡ªåŠ¨æ¨é€
+      */
+     void subscribe(URL url, NotifyListener listener);
+     
+     /**
+      * å–æ¶ˆè®¢é˜…
+      */
+     void unsubscribe(URL url, NotifyListener listener);
+     
+     /**
+      * æŸ¥è¯¢ç¬¦åˆæ¡ä»¶çš„å·²æ³¨å†Œæ•°æ®ï¼Œä¸è®¢é˜…çš„æ¨æ¨¡å¼ç›¸å¯¹åº”ï¼Œè¿™é‡Œä¸ºæ‹‰æ¨¡å¼ï¼Œåªè¿”å›ä¸€æ¬¡ç»“æœ
+      */
+     List<URL> lookup(URL url);
+ }
+ ```
+ 
+ ### ğŸŒ³ Zookeeper æ³¨å†Œä¸­å¿ƒå®ç°
+ 
+ Zookeeperæ˜¯Dubboé»˜è®¤å’Œæœ€å¸¸ç”¨çš„æ³¨å†Œä¸­å¿ƒå®ç°ï¼š
+ 
+ ```java
+ public class ZookeeperRegistry extends FailbackRegistry {
+     
+     private final static String DEFAULT_ROOT = "dubbo";
+     private final static String DEFAULT_ZOOKEEPER_PORT = "2181";
+     
+     private ZkClient zkClient;
+     private final String root;
+     private final Set<String> anyServices = new ConcurrentHashSet<String>();
+     private final ConcurrentMap<URL, ConcurrentMap<NotifyListener, ChildListener>> zkListeners = 
+         new ConcurrentHashMap<URL, ConcurrentMap<NotifyListener, ChildListener>>();
+     
+     public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) {
+         super(url);
+         if (url.isAnyHost()) {
+             throw new IllegalStateException("registry address is invalid");
+         }
+         
+         // è·å–æ ¹è·¯å¾„
+         String group = url.getParameter(GROUP_KEY, DEFAULT_ROOT);
+         if (!group.startsWith(PATH_SEPARATOR)) {
+             group = PATH_SEPARATOR + group;
+         }
+         this.root = group;
+         
+         // åˆ›å»ºZKå®¢æˆ·ç«¯
+         zkClient = zookeeperTransporter.connect(url);
+         zkClient.addStateListener(new StateListener() {
+             @Override
+             public void stateChanged(int state) {
+                 if (state == RECONNECTED) {
+                     try {
+                         recover();
+                     } catch (Exception e) {
+                         logger.error(e.getMessage(), e);
+                     }
+                 }
+             }
+         });
+     }
+     
+     @Override
+     protected void doRegister(URL url) {
+         try {
+             // åˆ›å»ºæŒä¹…åŒ–èŠ‚ç‚¹è·¯å¾„
+             String path = toUrlPath(url);
+             zkClient.create(path, false);
+         } catch (Throwable e) {
+             throw new RpcException("Failed to register " + url + " to zookeeper " + 
+                 getUrl() + ", cause: " + e.getMessage(), e);
+         }
+     }
+     
+     @Override
+     protected void doUnregister(URL url) {
+         try {
+             zkClient.delete(toUrlPath(url));
+         } catch (Throwable e) {
+             throw new RpcException("Failed to unregister " + url + " to zookeeper " + 
+                 getUrl() + ", cause: " + e.getMessage(), e);
+         }
+     }
+     
+     @Override
+     protected void doSubscribe(final URL url, final NotifyListener listener) {
+         try {
+             if (ANY_VALUE.equals(url.getServiceInterface())) {
+                 // è®¢é˜…æ‰€æœ‰æœåŠ¡
+                 String root = toRootPath();
+                 ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);
+                 if (listeners == null) {
+                     zkListeners.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, ChildListener>());
+                     listeners = zkListeners.get(url);
+                 }
+                 
+                 ChildListener zkListener = listeners.get(listener);
+                 if (zkListener == null) {
+                     listeners.putIfAbsent(listener, new ChildListener() {
+                         @Override
+                         public void childChanged(String parentPath, List<String> currentChilds) {
+                             for (String child : currentChilds) {
+                                 child = URL.decode(child);
+                                 if (!anyServices.contains(child)) {
+                                     anyServices.add(child);
+                                     subscribe(url.setPath(child).addParameters(
+                                         INTERFACE_KEY, child, 
+                                         CHECK_KEY, String.valueOf(false)), listener);
+                                 }
+                             }
+                         }
+                     });
+                     zkListener = listeners.get(listener);
+                 }
+                 
+                 zkClient.create(root, false);
+                 List<String> services = zkClient.addChildListener(root, zkListener);
+                 
+             } else {
+                 // è®¢é˜…ç‰¹å®šæœåŠ¡
+                 List<URL> urls = new ArrayList<URL>();
+                 for (String path : toCategoriesPath(url)) {
+                     ConcurrentMap<NotifyListener, ChildListener> listeners = zkListeners.get(url);
+                     if (listeners == null) {
+                         zkListeners.putIfAbsent(url, new ConcurrentHashMap<NotifyListener, ChildListener>());
+                         listeners = zkListeners.get(url);
+                     }
+                     
+                     ChildListener zkListener = listeners.get(listener);
+                     if (zkListener == null) {
+                         listeners.putIfAbsent(listener, new ChildListener() {
+                             @Override
+                             public void childChanged(String parentPath, List<String> currentChilds) {
+                                 ZookeeperRegistry.this.notify(url, listener, 
+                                     toUrlsWithCategory(url, parentPath, currentChilds));
+                             }
+                         });
+                         zkListener = listeners.get(listener);
+                     }
+                     
+                     zkClient.create(path, false);
+                     List<String> children = zkClient.addChildListener(path, zkListener);
+                     if (children != null) {
+                         urls.addAll(toUrlsWithCategory(url, path, children));
+                     }
+                 }
+                 notify(url, listener, urls);
+             }
+         } catch (Throwable e) {
+             throw new RpcException("Failed to subscribe " + url + " to zookeeper " + 
+                 getUrl() + ", cause: " + e.getMessage(), e);
+         }
+     }
+ }
+ ```
+ 
+ ### ğŸ“ ZooKeeper èŠ‚ç‚¹ç»“æ„
+ 
+ Dubboåœ¨ZooKeeperä¸­ä½¿ç”¨ä»¥ä¸‹èŠ‚ç‚¹ç»“æ„ï¼š
+ 
+ ```
+ /dubbo
+ â”œâ”€â”€ com.example.UserService           # æœåŠ¡æ¥å£
+ â”‚   â”œâ”€â”€ providers                     # æœåŠ¡æä¾›è€…ç›®å½•
+ â”‚   â”‚   â”œâ”€â”€ dubbo://192.168.1.100:20880/com.example.UserService?version=1.0.0&group=default
+ â”‚   â”‚   â””â”€â”€ dubbo://192.168.1.101:20880/com.example.UserService?version=1.0.0&group=default
+ â”‚   â”œâ”€â”€ consumers                     # æœåŠ¡æ¶ˆè´¹è€…ç›®å½•
+ â”‚   â”‚   â””â”€â”€ consumer://192.168.1.102/com.example.UserService?version=1.0.0&group=default
+ â”‚   â”œâ”€â”€ routers                       # è·¯ç”±è§„åˆ™ç›®å½•
+ â”‚   â”‚   â””â”€â”€ condition://0.0.0.0/com.example.UserService?rule=method=getUserById=>host=192.168.1.100
+ â”‚   â””â”€â”€ configurators                 # é…ç½®è§„åˆ™ç›®å½•
+ â”‚       â””â”€â”€ override://0.0.0.0/com.example.UserService?timeout=5000
+ ```
+ 
+ ### ğŸš¨ å®¹é”™æœºåˆ¶ - FailbackRegistry
+ 
+ FailbackRegistryå®ç°äº†æ³¨å†Œä¸­å¿ƒçš„å®¹é”™æœºåˆ¶ï¼š
+ 
+ ```java
+ public abstract class FailbackRegistry extends AbstractRegistry {
+     
+     // é‡è¯•å®šæ—¶å™¨
+     private final ScheduledExecutorService retryExecutor = 
+         Executors.newScheduledThreadPool(1, new NamedThreadFactory("DubboRegistryFailedRetryTimer", true));
+     
+     // å¤±è´¥çš„æ³¨å†Œè¯·æ±‚
+     private final Set<URL> failedRegistered = new ConcurrentHashSet<URL>();
+     // å¤±è´¥çš„å–æ¶ˆæ³¨å†Œè¯·æ±‚  
+     private final Set<URL> failedUnregistered = new ConcurrentHashSet<URL>();
+     // å¤±è´¥çš„è®¢é˜…è¯·æ±‚
+     private final ConcurrentMap<URL, Set<NotifyListener>> failedSubscribed = 
+         new ConcurrentHashMap<URL, Set<NotifyListener>>();
+     // å¤±è´¥çš„å–æ¶ˆè®¢é˜…è¯·æ±‚
+     private final ConcurrentMap<URL, Set<NotifyListener>> failedUnsubscribed = 
+         new ConcurrentHashMap<URL, Set<NotifyListener>>();
+     
+     public FailbackRegistry(URL url) {
+         super(url);
+         // å¯åŠ¨é‡è¯•å®šæ—¶å™¨
+         this.retryFuture = retryExecutor.scheduleWithFixedDelay(new Runnable() {
+             @Override
+             public void run() {
+                 try {
+                     retry();
+                 } catch (Throwable t) {
+                     logger.error("Unexpected error occur at failed retry, cause: " + t.getMessage(), t);
+                 }
+             }
+         }, retryPeriod, retryPeriod, TimeUnit.MILLISECONDS);
+     }
+     
+     @Override
+     public void register(URL url) {
+         super.register(url);
+         failedRegistered.remove(url);
+         failedUnregistered.remove(url);
+         try {
+             doRegister(url);
+         } catch (Exception e) {
+             Throwable t = e;
+             
+             // è®°å½•å¤±è´¥çš„æ³¨å†Œè¯·æ±‚åˆ°å¤±è´¥åˆ—è¡¨ï¼Œå®šæ—¶é‡è¯•
+             failedRegistered.add(url);
+             logger.error("Failed to register " + url + " to registry " + getUrl().getAddress() + 
+                 ", waiting for retry, cause: " + t.getMessage(), t);
+         }
+     }
+     
+     @Override
+     public void unregister(URL url) {
+         super.unregister(url);
+         failedRegistered.remove(url);
+         failedUnregistered.remove(url);
+         try {
+             doUnregister(url);
+         } catch (Exception e) {
+             Throwable t = e;
+             
+             // è®°å½•å¤±è´¥çš„å–æ¶ˆæ³¨å†Œè¯·æ±‚åˆ°å¤±è´¥åˆ—è¡¨ï¼Œå®šæ—¶é‡è¯•
+             failedUnregistered.add(url);
+             logger.error("Failed to unregister " + url + " to registry " + getUrl().getAddress() + 
+                 ", waiting for retry, cause: " + t.getMessage(), t);
+         }
+     }
+     
+     protected void retry() {
+         if (!failedRegistered.isEmpty()) {
+             Set<URL> failed = new HashSet<URL>(failedRegistered);
+             if (failed.size() > 0) {
+                 for (URL url : failed) {
+                     try {
+                         doRegister(url);
+                         failedRegistered.remove(url);
+                     } catch (Throwable t) {
+                         logger.warn("Failed to retry register " + failed + ", waiting for again, cause: " + 
+                             t.getMessage(), t);
+                     }
+                 }
+             }
+         }
+         
+         // é‡è¯•å…¶ä»–å¤±è´¥æ“ä½œ...
+     }
+ }
+ ```
+ 
+ ---
+ 
+ ## ç¬¬å…­ç« ï¼šè´Ÿè½½å‡è¡¡åŸç†
+ 
+ ### âš–ï¸ LoadBalance è´Ÿè½½å‡è¡¡æ¥å£
+ 
+ è´Ÿè½½å‡è¡¡æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„å…³é”®ç»„ä»¶ï¼ŒDubboæä¾›äº†å¤šç§è´Ÿè½½å‡è¡¡ç®—æ³•ï¼š
+ 
+ ```java
+ @SPI(RandomLoadBalance.NAME)
+ public interface LoadBalance {
+     
+     /**
+      * ä»å¤šä¸ªInvokerä¸­é€‰æ‹©ä¸€ä¸ª
+      * @param invokers å€™é€‰Invokeråˆ—è¡¨
+      * @param url URLä¿¡æ¯
+      * @param invocation è°ƒç”¨ä¿¡æ¯
+      * @return é€‰ä¸­çš„Invoker
+      */
+     @Adaptive("loadbalance")
+     <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) throws RpcException;
+ }
+ ```
+ 
+ #### AbstractLoadBalance æŠ½è±¡åŸºç±»
+ 
+ ```java
+ public abstract class AbstractLoadBalance implements LoadBalance {
+     
+     static int calculateWarmupWeight(int uptime, int warmup, int weight) {
+         int ww = (int) ((float) uptime / ((float) warmup / (float) weight));
+         return ww < 1 ? 1 : (ww > weight ? weight : ww);
+     }
+     
+     @Override
+     public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) {
+         if (invokers == null || invokers.isEmpty()) {
+             return null;
+         }
+         
+         if (invokers.size() == 1) {
+             return invokers.get(0);
+         }
+         
+         return doSelect(invokers, url, invocation);
+     }
+     
+     protected abstract <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation);
+     
+     protected int getWeight(Invoker<?> invoker, Invocation invocation) {
+         int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);
+         if (weight > 0) {
+             long timestamp = invoker.getUrl().getParameter(REMOTE_TIMESTAMP_KEY, 0L);
+             if (timestamp > 0L) {
+                 int uptime = (int) (System.currentTimeMillis() - timestamp);
+                 int warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);
+                 if (uptime > 0 && uptime < warmup) {
+                     weight = calculateWarmupWeight(uptime, warmup, weight);
+                 }
+             }
+         }
+         return weight >= 0 ? weight : 0;
+     }
+ }
+ ```
+ 
+ ### ğŸ² Random éšæœºè´Ÿè½½å‡è¡¡
+ 
+ æœ€ç®€å•çš„è´Ÿè½½å‡è¡¡ç®—æ³•ï¼Œéšæœºé€‰æ‹©ä¸€ä¸ªæä¾›è€…ï¼š
+ 
+ ```java
+ public class RandomLoadBalance extends AbstractLoadBalance {
+     
+     public static final String NAME = "random";
+     
+     @Override
+     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
+         int length = invokers.size();
+         boolean sameWeight = true;
+         int[] weights = new int[length];
+         int firstWeight = getWeight(invokers.get(0), invocation);
+         weights[0] = firstWeight;
+         int totalWeight = firstWeight;
+         
+         // è®¡ç®—æ€»æƒé‡ï¼Œæ£€æŸ¥æƒé‡æ˜¯å¦ç›¸åŒ
+         for (int i = 1; i < length; i++) {
+             int weight = getWeight(invokers.get(i), invocation);
+             weights[i] = weight;
+             totalWeight += weight;
+             if (sameWeight && weight != firstWeight) {
+                 sameWeight = false;
+             }
+         }
+         
+         // å¦‚æœæƒé‡ä¸åŒï¼ŒæŒ‰æƒé‡éšæœºé€‰æ‹©
+         if (totalWeight > 0 && !sameWeight) {
+             int offset = ThreadLocalRandom.current().nextInt(totalWeight);
+             for (int i = 0; i < length; i++) {
+                 offset -= weights[i];
+                 if (offset < 0) {
+                     return invokers.get(i);
+                 }
+             }
+         }
+         
+         // æƒé‡ç›¸åŒï¼Œç›´æ¥éšæœºé€‰æ‹©
+         return invokers.get(ThreadLocalRandom.current().nextInt(length));
+     }
+ }
+ ```
+ 
+ ### ğŸ”„ RoundRobin è½®è¯¢è´Ÿè½½å‡è¡¡
+ 
+ è½®è¯¢ç®—æ³•æŒ‰é¡ºåºé€‰æ‹©æä¾›è€…ï¼Œæ”¯æŒæƒé‡ï¼š
+ 
+ ```java
+ public class RoundRobinLoadBalance extends AbstractLoadBalance {
+     
+     public static final String NAME = "roundrobin";
+     
+     private static final int RECYCLE_PERIOD = 60000;
+     
+     protected static class WeightedRoundRobin {
+         private int weight;
+         private AtomicLong current = new AtomicLong(0);
+         private long lastUpdate;
+         
+         public int getWeight() {
+             return weight;
+         }
+         
+         public void setWeight(int weight) {
+             this.weight = weight;
+             current.set(0);
+         }
+         
+         public long increaseCurrent() {
+             return current.addAndGet(weight);
+         }
+         
+         public void sel(int total) {
+             current.addAndGet(-1 * total);
+         }
+         
+         public long getLastUpdate() {
+             return lastUpdate;
+         }
+         
+         public void setLastUpdate(long lastUpdate) {
+             this.lastUpdate = lastUpdate;
+         }
+     }
+     
+     private ConcurrentMap<String, ConcurrentMap<String, WeightedRoundRobin>> methodWeightMap = 
+         new ConcurrentHashMap<String, ConcurrentMap<String, WeightedRoundRobin>>();
+     
+     @Override
+     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
+         String key = invokers.get(0).getUrl().getServiceKey() + "." + invocation.getMethodName();
+         ConcurrentMap<String, WeightedRoundRobin> map = methodWeightMap.get(key);
+         if (map == null) {
+             methodWeightMap.putIfAbsent(key, new ConcurrentHashMap<String, WeightedRoundRobin>());
+             map = methodWeightMap.get(key);
+         }
+         
+         int totalWeight = 0;
+         long maxCurrent = Long.MIN_VALUE;
+         long now = System.currentTimeMillis();
+         Invoker<T> selectedInvoker = null;
+         WeightedRoundRobin selectedWRR = null;
+         
+         for (Invoker<T> invoker : invokers) {
+             String identifyString = invoker.getUrl().toIdentityString();
+             WeightedRoundRobin weightedRoundRobin = map.get(identifyString);
+             int weight = getWeight(invoker, invocation);
+             
+             if (weightedRoundRobin == null) {
+                 weightedRoundRobin = new WeightedRoundRobin();
+                 weightedRoundRobin.setWeight(weight);
+                 map.putIfAbsent(identifyString, weightedRoundRobin);
+             }
+             
+             if (weight != weightedRoundRobin.getWeight()) {
+                 weightedRoundRobin.setWeight(weight);
+             }
+             
+             long cur = weightedRoundRobin.increaseCurrent();
+             weightedRoundRobin.setLastUpdate(now);
+             
+             if (cur > maxCurrent) {
+                 maxCurrent = cur;
+                 selectedInvoker = invoker;
+                 selectedWRR = weightedRoundRobin;
+             }
+             
+             totalWeight += weight;
+         }
+         
+         if (!updateLock.tryLock()) {
+             return selectedInvoker;
+         }
+         
+         try {
+             // æ¸…ç†è¿‡æœŸçš„æƒé‡è®°å½•
+             if (now - lastUpdate > RECYCLE_PERIOD) {
+                 map.entrySet().removeIf(item -> now - item.getValue().getLastUpdate() > RECYCLE_PERIOD);
+                 lastUpdate = now;
+             }
+         } finally {
+             updateLock.unlock();
+         }
+         
+         if (selectedInvoker != null) {
+             selectedWRR.sel(totalWeight);
+             return selectedInvoker;
+         }
+         
+         return invokers.get(0);
+     }
+ }
+ ```
+ 
+ ### âš¡ LeastActive æœ€å°‘æ´»è·ƒè´Ÿè½½å‡è¡¡
+ 
+ æœ€å°‘æ´»è·ƒç®—æ³•æ ¹æ®æ´»è·ƒè¯·æ±‚æ•°é€‰æ‹©æä¾›è€…ï¼Œæ´»è·ƒæ•°è¶Šå°‘è¯´æ˜å¤„ç†èƒ½åŠ›è¶Šå¼ºï¼š
+ 
+ ```java
+ public class LeastActiveLoadBalance extends AbstractLoadBalance {
+     
+     public static final String NAME = "leastactive";
+     
+     @Override
+     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
+         int length = invokers.size();
+         int leastActive = -1;
+         int leastCount = 0;
+         int[] leastIndexes = new int[length];
+         int[] weights = new int[length];
+         int totalWeight = 0;
+         int firstWeight = 0;
+         boolean sameWeight = true;
+         
+         // æ‰¾å‡ºæ´»è·ƒæ•°æœ€å°çš„Invoker
+         for (int i = 0; i < length; i++) {
+             Invoker<T> invoker = invokers.get(i);
+             int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();
+             int afterWarmup = getWeight(invoker, invocation);
+             weights[i] = afterWarmup;
+             
+             if (leastActive == -1 || active < leastActive) {
+                 leastActive = active;
+                 leastCount = 1;
+                 leastIndexes[0] = i;
+                 totalWeight = afterWarmup;
+                 firstWeight = afterWarmup;
+                 sameWeight = true;
+             } else if (active == leastActive) {
+                 leastIndexes[leastCount++] = i;
+                 totalWeight += afterWarmup;
+                 if (sameWeight && i > 0 && afterWarmup != firstWeight) {
+                     sameWeight = false;
+                 }
+             }
+         }
+         
+         // å¦‚æœåªæœ‰ä¸€ä¸ªæœ€å°æ´»è·ƒæ•°çš„Invokerï¼Œç›´æ¥è¿”å›
+         if (leastCount == 1) {
+             return invokers.get(leastIndexes[0]);
+         }
+         
+         // å¦‚æœæœ‰å¤šä¸ªç›¸åŒæœ€å°æ´»è·ƒæ•°çš„Invokerï¼ŒæŒ‰æƒé‡éšæœºé€‰æ‹©
+         if (!sameWeight && totalWeight > 0) {
+             int offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);
+             for (int i = 0; i < leastCount; i++) {
+                 int leastIndex = leastIndexes[i];
+                 offsetWeight -= weights[leastIndex];
+                 if (offsetWeight < 0) {
+                     return invokers.get(leastIndex);
+                 }
+             }
+         }
+         
+         // æƒé‡ç›¸åŒï¼Œéšæœºé€‰æ‹©
+         return invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]);
+     }
+ }
+ ```
+ 
+ ### ğŸ”— ConsistentHash ä¸€è‡´æ€§å“ˆå¸Œè´Ÿè½½å‡è¡¡
+ 
+ ä¸€è‡´æ€§å“ˆå¸Œç®—æ³•ç¡®ä¿ç›¸åŒå‚æ•°çš„è¯·æ±‚æ€»æ˜¯è·¯ç”±åˆ°åŒä¸€å°æœºå™¨ï¼š
+ 
+ ```java
+ public class ConsistentHashLoadBalance extends AbstractLoadBalance {
+     
+     public static final String NAME = "consistenthash";
+     
+     private static final String HASH_NODES = "hash.nodes";
+     private static final String HASH_ARGUMENTS = "hash.arguments";
+     
+     private final ConcurrentMap<String, ConsistentHashSelector<?>> selectors = 
+         new ConcurrentHashMap<String, ConsistentHashSelector<?>>();
+     
+     @Override
+     protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
+         String methodName = RpcUtils.getMethodName(invocation);
+         String key = invokers.get(0).getUrl().getServiceKey() + "." + methodName;
+         
+         int identityHashCode = System.identityHashCode(invokers);
+         ConsistentHashSelector<T> selector = (ConsistentHashSelector<T>) selectors.get(key);
+         
+         if (selector == null || selector.identityHashCode != identityHashCode) {
+             selectors.put(key, new ConsistentHashSelector<T>(invokers, methodName, identityHashCode));
+             selector = (ConsistentHashSelector<T>) selectors.get(key);
+         }
+         
+         return selector.select(invocation);
+     }
+     
+     private static final class ConsistentHashSelector<T> {
+         
+         private final TreeMap<Long, Invoker<T>> virtualInvokers;
+         private final int replicaNumber;
+         private final int identityHashCode;
+         private final int[] argumentIndex;
+         
+         ConsistentHashSelector(List<Invoker<T>> invokers, String methodName, int identityHashCode) {
+             this.virtualInvokers = new TreeMap<Long, Invoker<T>>();
+             this.identityHashCode = identityHashCode;
+             
+             URL url = invokers.get(0).getUrl();
+             this.replicaNumber = url.getMethodParameter(methodName, HASH_NODES, 160);
+             String[] index = COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, HASH_ARGUMENTS, "0"));
+             argumentIndex = new int[index.length];
+             for (int i = 0; i < index.length; i++) {
+                 argumentIndex[i] = Integer.parseInt(index[i]);
+             }
+             
+             for (Invoker<T> invoker : invokers) {
+                 String address = invoker.getUrl().getAddress();
+                 for (int i = 0; i < replicaNumber / 4; i++) {
+                     byte[] digest = md5(address + i);
+                     for (int h = 0; h < 4; h++) {
+                         long m = hash(digest, h);
+                         virtualInvokers.put(m, invoker);
+                     }
+                 }
+             }
+         }
+         
+         public Invoker<T> select(Invocation invocation) {
+             String key = toKey(invocation.getArguments());
+             byte[] digest = md5(key);
+             return selectForKey(hash(digest, 0));
+         }
+         
+         private String toKey(Object[] args) {
+             StringBuilder buf = new StringBuilder();
+             for (int i : argumentIndex) {
+                 if (i >= 0 && i < args.length) {
+                     buf.append(args[i]);
+                 }
+             }
+             return buf.toString();
+         }
+         
+         private Invoker<T> selectForKey(long hash) {
+             Map.Entry<Long, Invoker<T>> entry = virtualInvokers.ceilingEntry(hash);
+             if (entry == null) {
+                 entry = virtualInvokers.firstEntry();
+             }
+             return entry.getValue();
+         }
+         
+         private long hash(byte[] digest, int number) {
+             return (((long) (digest[3 + number * 4] & 0xFF) << 24)
+                 | ((long) (digest[2 + number * 4] & 0xFF) << 16)
+                 | ((long) (digest[1 + number * 4] & 0xFF) << 8)
+                 | (digest[number * 4] & 0xFF))
+                 & 0xFFFFFFFFL;
+         }
+         
+         private byte[] md5(String value) {
+             MessageDigest md5;
+             try {
+                 md5 = MessageDigest.getInstance("MD5");
+             } catch (NoSuchAlgorithmException e) {
+                 throw new IllegalStateException(e.getMessage(), e);
+             }
+             md5.reset();
+             byte[] bytes = value.getBytes(StandardCharsets.UTF_8);
+             md5.update(bytes);
+             return md5.digest();
+         }
+     }
+ }
+ ```
+ 
+ ---
+ 
+ ## ç¬¬ä¸ƒç« ï¼šé›†ç¾¤å®¹é”™åŸç†
+ 
+ ### ğŸ›¡ï¸ Cluster é›†ç¾¤æ¥å£è®¾è®¡
+ 
+ é›†ç¾¤å®¹é”™æ˜¯Dubboå¤„ç†åˆ†å¸ƒå¼ç¯å¢ƒä¸‹æœåŠ¡è°ƒç”¨å¤±è´¥çš„æ ¸å¿ƒæœºåˆ¶ï¼š
+ 
+ ```java
+ @SPI(FailoverCluster.NAME)
+ public interface Cluster {
+     
+     /**
+      * å°†å¤šä¸ªInvokeråˆå¹¶æˆä¸€ä¸ªé›†ç¾¤Invoker
+      */
+     @Adaptive
+     <T> Invoker<T> join(Directory<T> directory) throws RpcException;
+ }
+ ```
+ 
+ #### AbstractCluster æŠ½è±¡å®ç°
+ 
+ ```java
+ public abstract class AbstractCluster implements Cluster {
+     
+     @Override
+     public <T> Invoker<T> join(Directory<T> directory) throws RpcException {
+         return buildClusterInterceptors(createInvoker(directory), directory.getUrl().getParameter(REFERENCE_INTERCEPTOR_KEY));
+     }
+     
+     protected abstract <T> AbstractClusterInvoker<T> createInvoker(Directory<T> directory);
+     
+     private <T> Invoker<T> buildClusterInterceptors(AbstractClusterInvoker<T> clusterInvoker, String key) {
+         AbstractClusterInvoker<T> last = clusterInvoker;
+         List<ClusterInterceptor> interceptors = ExtensionLoader.getExtensionLoader(ClusterInterceptor.class).getActivateExtension(clusterInvoker.getUrl(), key);
+         
+         if (!interceptors.isEmpty()) {
+             for (int i = interceptors.size() - 1; i >= 0; i--) {
+                 final ClusterInterceptor interceptor = interceptors.get(i);
+                 final AbstractClusterInvoker<T> next = last;
+                 last = new InterceptorInvokerNode<>(clusterInvoker, interceptor, next);
+             }
+         }
+         return last;
+     }
+ }
+ ```
+ 
+ #### AbstractClusterInvoker æŠ½è±¡é›†ç¾¤è°ƒç”¨å™¨
+ 
+ ```java
+ public abstract class AbstractClusterInvoker<T> implements Invoker<T> {
+     
+     protected Directory<T> directory;
+     protected boolean availablecheck;
+     private AtomicBoolean destroyed = new AtomicBoolean(false);
+     
+     @Override
+     public Result invoke(final Invocation invocation) throws RpcException {
+         checkWhetherDestroyed();
+         
+         // è·å–è´Ÿè½½å‡è¡¡å™¨
+         LoadBalance loadbalance = null;
+         List<Invoker<T>> invokers = list(invocation);
+         if (invokers != null && !invokers.isEmpty()) {
+             loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(0).getUrl()
+                 .getMethodParameter(RpcUtils.getMethodName(invocation), LOADBALANCE_KEY, DEFAULT_LOADBALANCE));
+         }
+         
+         // è®¾ç½®è°ƒç”¨ID
+         RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
+         
+         return doInvoke(invocation, invokers, loadbalance);
+     }
+     
+     protected List<Invoker<T>> list(Invocation invocation) throws RpcException {
+         return directory.list(invocation);
+     }
+     
+     protected abstract Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException;
+     
+     protected Invoker<T> select(LoadBalance loadbalance, Invocation invocation, 
+                                List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {
+         
+         if (invokers == null || invokers.isEmpty()) {
+             return null;
+         }
+         
+         String methodName = invocation == null ? DEFAULT_KEY : invocation.getMethodName();
+         boolean sticky = invokers.get(0).getUrl().getMethodParameter(methodName, CLUSTER_STICKY_KEY, DEFAULT_CLUSTER_STICKY);
+         
+         // ç²˜æ€§è°ƒç”¨
+         if (stickyInvoker != null && !invokers.contains(stickyInvoker)) {
+             stickyInvoker = null;
+         }
+         
+         if (sticky && stickyInvoker != null && 
+             (selected == null || !selected.contains(stickyInvoker))) {
+             if (availablecheck && stickyInvoker.isAvailable()) {
+                 return stickyInvoker;
+             }
+         }
+         
+         // è´Ÿè½½å‡è¡¡é€‰æ‹©
+         Invoker<T> invoker = doSelect(loadbalance, invocation, invokers, selected);
+         
+         if (sticky) {
+             stickyInvoker = invoker;
+         }
+         
+         return invoker;
+     }
+     
+     private Invoker<T> doSelect(LoadBalance loadbalance, Invocation invocation,
+                                List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {
+         
+         if (invokers == null || invokers.isEmpty()) {
+             return null;
+         }
+         
+         if (invokers.size() == 1) {
+             return invokers.get(0);
+         }
+         
+         Invoker<T> invoker = loadbalance.select(invokers, getUrl(), invocation);
+         
+         // å¦‚æœé€‰ä¸­çš„Invokeråœ¨å·²é€‰åˆ—è¡¨ä¸­æˆ–ä¸å¯ç”¨ï¼Œé‡æ–°é€‰æ‹©
+         if ((selected != null && selected.contains(invoker))
+             || (!invoker.isAvailable() && getUrl() != null && availablecheck)) {
+             
+             try {
+                 Invoker<T> rInvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);
+                 if (rInvoker != null) {
+                     invoker = rInvoker;
+                 }
+             } catch (Throwable t) {
+                 logger.error("Failed to re-select invoker for service " + getInterface());
+             }
+         }
+         
+         return invoker;
+     }
+ }
+ ```
+ 
+ ### ğŸ”„ FailoverCluster å¤±è´¥è½¬ç§»å®¹é”™
+ 
+ å¤±è´¥è½¬ç§»æ˜¯é»˜è®¤çš„å®¹é”™ç­–ç•¥ï¼Œå¤±è´¥æ—¶è‡ªåŠ¨åˆ‡æ¢åˆ°å…¶ä»–æä¾›è€…ï¼š
+ 
+ ```java
+ public class FailoverClusterInvoker<T> extends AbstractClusterInvoker<T> {
+     
+     @Override
+     public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
+         List<Invoker<T>> copyInvokers = invokers;
+         checkInvokers(copyInvokers, invocation);
+         
+         String methodName = RpcUtils.getMethodName(invocation);
+         int len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + 1;
+         if (len <= 0) {
+             len = 1;
+         }
+         
+         RpcException le = null;
+         List<Invoker<T>> invoked = new ArrayList<Invoker<T>>(copyInvokers.size());
+         Set<String> providers = new HashSet<String>(len);
+         
+         for (int i = 0; i < len; i++) {
+             if (i > 0) {
+                 checkWhetherDestroyed();
+                 copyInvokers = list(invocation);
+                 checkInvokers(copyInvokers, invocation);
+             }
+             
+             Invoker<T> invoker = select(loadbalance, invocation, copyInvokers, invoked);
+             invoked.add(invoker);
+             RpcContext.getContext().setInvokers((List) invoked);
+             
+             try {
+                 Result result = invoker.invoke(invocation);
+                 if (le != null && logger.isWarnEnabled()) {
+                     logger.warn("Although retry the method " + methodName
+                         + " in the service " + getInterface().getName()
+                         + " was successful by the provider " + invoker.getUrl().getAddress()
+                         + ", but there have been failed providers " + providers
+                         + " (" + providers.size() + "/" + copyInvokers.size()
+                         + ") from the registry " + directory.getUrl().getAddress()
+                         + " on the consumer " + NetUtils.getLocalHost()
+                         + " using the dubbo version " + Version.getVersion() + ".");
+                 }
+                 return result;
+             } catch (RpcException e) {
+                 if (e.isBiz()) {
+                     throw e;
+                 }
+                 le = e;
+             } catch (Throwable e) {
+                 le = new RpcException(e.getMessage(), e);
+             } finally {
+                 providers.add(invoker.getUrl().getAddress());
+             }
+         }
+         
+         throw new RpcException(le.getCode(), 
+             "Failed to invoke the method " + methodName + " in the service " + getInterface().getName() 
+             + ". Tried " + len + " times of the providers " + providers 
+             + " (" + providers.size() + "/" + copyInvokers.size() 
+             + ") from the registry " + directory.getUrl().getAddress() 
+             + " on the consumer " + NetUtils.getLocalHost() + " using the dubbo version " + Version.getVersion() 
+             + ". Last error is: " + le.getMessage(), le.getCause() != null ? le.getCause() : le);
+     }
+ }
+ ```
+ 
+ ### âš¡ FailfastCluster å¿«é€Ÿå¤±è´¥å®¹é”™
+ 
+ å¿«é€Ÿå¤±è´¥ç­–ç•¥åªè°ƒç”¨ä¸€æ¬¡ï¼Œå¤±è´¥ç«‹å³æŠ¥é”™ï¼Œé€‚ç”¨äºå†™æ“ä½œï¼š
+ 
+ ```java
+ public class FailfastClusterInvoker<T> extends AbstractClusterInvoker<T> {
+     
+     @Override
+     public Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
+         checkInvokers(invokers, invocation);
+         Invoker<T> invoker = select(loadbalance, invocation, invokers, null);
+         
+         try {
+             return invoker.invoke(invocation);
+         } catch (Throwable e) {
+             if (e instanceof RpcException && ((RpcException) e).isBiz()) {
+                 throw (RpcException) e;
+             }
+             throw new RpcException(e instanceof RpcException ? ((RpcException) e).getCode() : 0,
+                 "Failfast invoke providers " + invoker.getUrl() + " " + loadbalance.getClass().getSimpleName()
+                 + " select from all providers " + invokers + " for service " + getInterface().getName()
+                 + " method " + invocation.getMethodName() + " on consumer " + NetUtils.getLocalHost()
+                 + " use dubbo version " + Version.getVersion() 
+                 + ", but no luck to perform the invocation. Last error is: " + e.getMessage(),
+                 e.getCause() != null ? e.getCause() : e);
+         }
+     }
+ }
+ ```
+ 
+ ### ğŸ”‡ FailsafeCluster å¤±è´¥å®‰å…¨å®¹é”™
+ 
+ å¤±è´¥å®‰å…¨ç­–ç•¥å¤±è´¥æ—¶å¿½ç•¥å¼‚å¸¸ï¼Œé€‚ç”¨äºç›‘æ§ç­‰ä¸é‡è¦çš„æœåŠ¡ï¼š
+ 
+ ```java
+ public class FailsafeClusterInvoker<T> extends AbstractClusterInvoker<T> {
+     
+     @Override
+     public Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
+         try {
+             checkInvokers(invokers, invocation);
+             Invoker<T> invoker = select(loadbalance, invocation, invokers, null);
+             return invoker.invoke(invocation);
+         } catch (Throwable e) {
+             logger.error("Failsafe ignore exception: " + e.getMessage(), e);
+             return new RpcResult(); // è¿”å›ç©ºç»“æœ
+         }
+     }
+ }
+ ```
  
```

---

ç°åœ¨è®©æˆ‘ç»§ç»­æ·»åŠ å‰©ä½™çš„æ ¸å¿ƒåŸç†ç« èŠ‚ï¼š

---

Error calling tool 'edit_file'.

---

è®©æˆ‘ç»§ç»­æ·»åŠ å‰©ä½™çš„å…³é”®ç« èŠ‚ï¼š

---

```diff
          return invoker;
      }
-     
-     private Invoker<T> doSelect(LoadBalance loadbalance, Invocation invocation,
-                                List<Invoker<T>> invokers, List<Invoker<T>> selected) throws RpcException {
-         
-         if (invokers == null || invokers.isEmpty()) {
-             return null;
-         }
-         
-         if (invokers.size() == 1) {
-             return invokers.get(0);
-         }
-         
-         Invoker<T> invoker = loadbalance.select(invokers, getUrl(), invocation);
-         
-         // å¦‚æœé€‰ä¸­çš„Invokeråœ¨å·²é€‰åˆ—è¡¨ä¸­æˆ–ä¸å¯ç”¨ï¼Œé‡æ–°é€‰æ‹©
-         if ((selected != null && selected.contains(invoker))
-             || (!invoker.isAvailable() && getUrl() != null && availablecheck)) {
-             
-             try {
-                 Invoker<T> rInvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);
-                 if (rInvoker != null) {
-                     invoker = rInvoker;
-                 }
-             } catch (Throwable t) {
-                 logger.error("Failed to re-select invoker for service " + getInterface());
-             }
-         }
-         
-         return invoker;
-     }
  }
  ```
```

```diff
  }
  ```
+ 
+ ---
+ 
+ ## ç¬¬å…«ç« ï¼šç½‘ç»œé€šä¿¡åŸç†
+ 
+ ### ğŸŒ Remoting å±‚æ¶æ„
+ 
+ Dubboçš„ç½‘ç»œé€šä¿¡åŸºäºRemotingå±‚ï¼Œé‡‡ç”¨åˆ†å±‚è®¾è®¡ï¼š
+ 
+ ```
+ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
+ â”‚              Exchange               â”‚  ä¿¡æ¯äº¤æ¢å±‚
+ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
+ â”‚              Transport              â”‚  ç½‘ç»œä¼ è¾“å±‚  
+ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
+ â”‚              Codec                  â”‚  ç¼–è§£ç å±‚
+ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+ ```
+ 
+ #### Transport ä¼ è¾“å±‚æ¥å£
+ 
+ ```java
+ public interface Transporter {
+     
+     /**
+      * ç»‘å®šæœåŠ¡å™¨
+      */
+     @Adaptive({Constants.SERVER_KEY, Constants.TRANSPORTER_KEY})
+     Server bind(URL url, ChannelHandler handler) throws RemotingException;
+     
+     /**
+      * è¿æ¥æœåŠ¡å™¨
+      */
+     @Adaptive({Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY})
+     Client connect(URL url, ChannelHandler handler) throws RemotingException;
+ }
+ ```
+ 
+ #### Netty Transport å®ç°
+ 
+ ```java
+ public class NettyTransporter implements Transporter {
+     
+     @Override
+     public Server bind(URL url, ChannelHandler listener) throws RemotingException {
+         return new NettyServer(url, listener);
+     }
+     
+     @Override
+     public Client connect(URL url, ChannelHandler listener) throws RemotingException {
+         return new NettyClient(url, listener);
+     }
+ }
+ 
+ public class NettyServer extends AbstractServer implements Server {
+     
+     private Map<String, Channel> channels; // <ip:port, channel>
+     private ServerBootstrap bootstrap;
+     private io.netty.channel.Channel channel;
+     private EventLoopGroup bossGroup;
+     private EventLoopGroup workerGroup;
+     
+     public NettyServer(URL url, ChannelHandler handler) throws RemotingException {
+         super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));
+     }
+     
+     @Override
+     protected void doOpen() throws Throwable {
+         bootstrap = new ServerBootstrap();
+         
+         bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory("NettyServerBoss", true));
+         workerGroup = new NioEventLoopGroup(getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),
+                 new DefaultThreadFactory("NettyServerWorker", true));
+         
+         final NettyServerHandler nettyServerHandler = new NettyServerHandler(getUrl(), this);
+         channels = nettyServerHandler.getChannels();
+         
+         bootstrap.group(bossGroup, workerGroup)
+                 .channel(NioServerSocketChannel.class)
+                 .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)
+                 .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE)
+                 .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
+                 .childHandler(new ChannelInitializer<NioSocketChannel>() {
+                     @Override
+                     protected void initChannel(NioSocketChannel ch) throws Exception {
+                         NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);
+                         ch.pipeline()
+                                 .addLast("decoder", adapter.getDecoder())
+                                 .addLast("encoder", adapter.getEncoder())
+                                 .addLast("handler", nettyServerHandler);
+                     }
+                 });
+         
+         // ç»‘å®šç«¯å£
+         ChannelFuture channelFuture = bootstrap.bind(getBindAddress());
+         channelFuture.syncUninterruptibly();
+         channel = channelFuture.channel();
+     }
+     
+     @Override
+     protected void doClose() throws Throwable {
+         try {
+             if (channel != null) {
+                 channel.close();
+             }
+         } catch (Throwable e) {
+             logger.warn(e.getMessage(), e);
+         }
+         
+         try {
+             Collection<com.alibaba.dubbo.remoting.Channel> channels = getChannels();
+             if (channels != null && !channels.isEmpty()) {
+                 for (com.alibaba.dubbo.remoting.Channel channel : channels) {
+                     try {
+                         channel.close();
+                     } catch (Throwable e) {
+                         logger.warn(e.getMessage(), e);
+                     }
+                 }
+             }
+         } catch (Throwable e) {
+             logger.warn(e.getMessage(), e);
+         }
+         
+         try {
+             if (bootstrap != null) {
+                 bossGroup.shutdownGracefully();
+                 workerGroup.shutdownGracefully();
+             }
+         } catch (Throwable e) {
+             logger.warn(e.getMessage(), e);
+         }
+     }
+ }
+ ```
+ 
+ ### ğŸ’¬ Exchange ä¿¡æ¯äº¤æ¢å±‚
+ 
+ Exchangeå±‚è´Ÿè´£è¯·æ±‚å“åº”æ¨¡å¼çš„å°è£…ï¼š
+ 
+ ```java
+ public interface ExchangeChannel extends Channel {
+     
+     /**
+      * å‘é€è¯·æ±‚
+      */
+     CompletableFuture<Object> request(Object request) throws RemotingException;
+     
+     /**
+      * å‘é€è¯·æ±‚ï¼ˆå¸¦è¶…æ—¶ï¼‰
+      */
+     CompletableFuture<Object> request(Object request, int timeout) throws RemotingException;
+     
+     /**
+      * è·å–Exchangeå¤„ç†å™¨
+      */
+     ExchangeHandler getExchangeHandler();
+ }
+ 
+ public class HeaderExchangeChannel implements ExchangeChannel {
+     
+     private final Channel channel;
+     private volatile boolean closed = false;
+     
+     @Override
+     public CompletableFuture<Object> request(Object request, int timeout) throws RemotingException {
+         if (closed) {
+             throw new RemotingException(this.getLocalAddress(), null, "Failed to send request " + request + ", cause: The channel " + this + " is closed!");
+         }
+         
+         // åˆ›å»ºè¯·æ±‚å¯¹è±¡
+         Request req = new Request();
+         req.setVersion(Version.getProtocolVersion());
+         req.setTwoWay(true);
+         req.setData(request);
+         
+         // åˆ›å»ºFuture
+         DefaultFuture future = DefaultFuture.newFuture(channel, req, timeout);
+         
+         try {
+             channel.send(req);
+         } catch (RemotingException e) {
+             future.cancel();
+             throw e;
+         }
+         
+         return future;
+     }
+ }
+ ```
+ 
+ #### DefaultFuture å¼‚æ­¥ç»“æœå¤„ç†
+ 
+ ```java
+ public class DefaultFuture extends CompletableFuture<Object> {
+     
+     private static final Map<Long, Channel> CHANNELS = new ConcurrentHashMap<Long, Channel>();
+     private static final Map<Long, DefaultFuture> FUTURES = new ConcurrentHashMap<Long, DefaultFuture>();
+     
+     private final long id;
+     private final Channel channel;
+     private final Request request;
+     private final int timeout;
+     private final long start = System.currentTimeMillis();
+     private volatile long sent;
+     
+     public static DefaultFuture newFuture(Channel channel, Request request, int timeout) {
+         final DefaultFuture future = new DefaultFuture(channel, request, timeout);
+         
+         // è¶…æ—¶å¤„ç†
+         timeoutCheck(future);
+         
+         return future;
+     }
+     
+     public static void received(Channel channel, Response response) {
+         try {
+             DefaultFuture future = FUTURES.remove(response.getId());
+             if (future != null) {
+                 Timeout timeout = future.timeoutCheckTask;
+                 if (timeout != null) {
+                     timeout.cancel();
+                 }
+                 future.doReceived(response);
+             } else {
+                 logger.warn("The timeout response finally returned at " 
+                     + (new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS").format(new Date())) 
+                     + ", response " + response 
+                     + (channel == null ? "" : ", channel: " + channel.getLocalAddress() 
+                         + " -> " + channel.getRemoteAddress()));
+             }
+         } finally {
+             CHANNELS.remove(response.getId());
+         }
+     }
+     
+     private void doReceived(Response res) {
+         if (res == null) {
+             throw new IllegalStateException("response cannot be null");
+         }
+         
+         if (res.getStatus() == Response.OK) {
+             this.complete(res.getResult());
+         } else if (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) {
+             this.completeExceptionally(new TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage()));
+         } else {
+             this.completeExceptionally(new RemotingException(channel, res.getErrorMessage()));
+         }
+     }
+ }
+ ```
+ 
+ ---
+ 
+ ## ç¬¬ä¹ç« ï¼šåºåˆ—åŒ–åŸç†
+ 
+ ### ğŸ“¦ Serialization åºåˆ—åŒ–æ¥å£
+ 
+ Dubboæ”¯æŒå¤šç§åºåˆ—åŒ–æ–¹å¼ï¼Œé€šè¿‡SPIæœºåˆ¶å¯æ‰©å±•ï¼š
+ 
+ ```java
+ @SPI("hessian2")
+ public interface Serialization {
+     
+     /**
+      * è·å–å†…å®¹ç±»å‹æ ‡è¯†
+      */
+     byte getContentTypeId();
+     
+     /**
+      * è·å–å†…å®¹ç±»å‹
+      */
+     String getContentType();
+     
+     /**
+      * åˆ›å»ºåºåˆ—åŒ–å™¨
+      */
+     @Adaptive
+     ObjectOutput serialize(URL url, OutputStream output) throws IOException;
+     
+     /**
+      * åˆ›å»ºååºåˆ—åŒ–å™¨
+      */
+     @Adaptive  
+     ObjectInput deserialize(URL url, InputStream input) throws IOException;
+ }
+ ```
+ 
+ ### ğŸš€ Hessian2 åºåˆ—åŒ–å®ç°
+ 
+ Hessian2æ˜¯Dubboé»˜è®¤çš„åºåˆ—åŒ–æ–¹å¼ï¼Œæ€§èƒ½ä¼˜ç§€ï¼š
+ 
+ ```java
+ public class Hessian2Serialization implements Serialization {
+     
+     @Override
+     public byte getContentTypeId() {
+         return HESSIAN2_SERIALIZATION_ID;
+     }
+     
+     @Override
+     public String getContentType() {
+         return "x-application/hessian2";
+     }
+     
+     @Override
+     public ObjectOutput serialize(URL url, OutputStream out) throws IOException {
+         return new Hessian2ObjectOutput(out);
+     }
+     
+     @Override
+     public ObjectInput deserialize(URL url, InputStream is) throws IOException {
+         return new Hessian2ObjectInput(is);
+     }
+ }
+ 
+ public class Hessian2ObjectOutput implements ObjectOutput {
+     
+     private final Hessian2Output mH2o;
+     
+     public Hessian2ObjectOutput(OutputStream os) {
+         mH2o = new Hessian2Output(os);
+         mH2o.setSerializerFactory(Hessian2SerializerFactory.SERIALIZER_FACTORY);
+     }
+     
+     @Override
+     public void writeObject(Object obj) throws IOException {
+         mH2o.writeObject(obj);
+     }
+     
+     @Override
+     public void writeUTF(String v) throws IOException {
+         mH2o.writeString(v);
+     }
+     
+     @Override
+     public void writeInt(int v) throws IOException {
+         mH2o.writeInt(v);
+     }
+     
+     @Override
+     public void flushBuffer() throws IOException {
+         mH2o.flushBuffer();
+     }
+ }
+ ```
+ 
+ ### âš¡ Kryo åºåˆ—åŒ–å®ç°
+ 
+ Kryoæ˜¯é«˜æ€§èƒ½çš„åºåˆ—åŒ–æ¡†æ¶ï¼Œé€‚ç”¨äºé«˜å¹¶å‘åœºæ™¯ï¼š
+ 
+ ```java
+ public class KryoSerialization implements Serialization {
+     
+     @Override
+     public byte getContentTypeId() {
+         return KRYO_SERIALIZATION_ID;
+     }
+     
+     @Override
+     public String getContentType() {
+         return "x-application/kryo";
+     }
+     
+     @Override
+     public ObjectOutput serialize(URL url, OutputStream output) throws IOException {
+         return new KryoObjectOutput(output);
+     }
+     
+     @Override
+     public ObjectInput deserialize(URL url, InputStream input) throws IOException {
+         return new KryoObjectInput(input);
+     }
+ }
+ 
+ public class KryoObjectOutput implements ObjectOutput {
+     
+     private Kryo kryo;
+     private Output output;
+     
+     public KryoObjectOutput(OutputStream outputStream) {
+         kryo = KryoUtils.get();
+         output = new Output(outputStream);
+     }
+     
+     @Override
+     public void writeObject(Object obj) throws IOException {
+         kryo.writeClassAndObject(output, obj);
+     }
+     
+     @Override
+     public void flushBuffer() throws IOException {
+         try {
+             output.flush();
+         } finally {
+             KryoUtils.release(kryo);
+             kryo = null;
+         }
+     }
+ }
+ 
+ // Kryoå¯¹è±¡æ± ç®¡ç†
+ public class KryoUtils {
+     
+     private static final ThreadLocal<Kryo> kryos = new ThreadLocal<Kryo>() {
+         @Override
+         protected Kryo initialValue() {
+             Kryo kryo = new Kryo();
+             kryo.setReferences(false);
+             kryo.setRegistrationRequired(false);
+             kryo.setInstantiatorStrategy(new DefaultInstantiatorStrategy(new StdInstantiatorStrategy()));
+             return kryo;
+         }
+     };
+     
+     public static Kryo get() {
+         return kryos.get();
+     }
+     
+     public static void release(Kryo kryo) {
+         // Kryoå¯¹è±¡å¯ä»¥é‡ç”¨ï¼Œè¿™é‡Œä¸éœ€è¦ç‰¹æ®Šå¤„ç†
+     }
+ }
+ ```
+ 
+ ---
+ 
+ ## ç¬¬åç« ï¼šSPIæ‰©å±•åŸç†
+ 
+ ### ğŸ”Œ ExtensionLoader æ‰©å±•åŠ è½½å™¨
+ 
+ Dubboçš„SPIæœºåˆ¶æ˜¯å…¶å¼ºå¤§æ‰©å±•æ€§çš„æ ¸å¿ƒï¼ŒExtensionLoaderæ˜¯SPIçš„å®ç°ï¼š
+ 
+ ```java
+ public class ExtensionLoader<T> {
+     
+     private static final ConcurrentMap<Class<?>, ExtensionLoader<?>> EXTENSION_LOADERS = 
+         new ConcurrentHashMap<Class<?>, ExtensionLoader<?>>();
+     
+     private static final ConcurrentMap<Class<?>, Object> EXTENSION_INSTANCES = 
+         new ConcurrentHashMap<Class<?>, Object>();
+     
+     private final Class<?> type;
+     private final ExtensionFactory objectFactory;
+     
+     private final ConcurrentMap<Class<?>, String> cachedNames = new ConcurrentHashMap<Class<?>, String>();
+     private final Holder<Map<String, Class<?>>> cachedClasses = new Holder<Map<String, Class<?>>>();
+     private final Map<String, Object> cachedActivates = new ConcurrentHashMap<String, Object>();
+     private final ConcurrentMap<String, Holder<Object>> cachedInstances = new ConcurrentHashMap<String, Holder<Object>>();
+     private final Holder<Object> cachedAdaptiveInstance = new Holder<Object>();
+     private volatile Class<?> cachedAdaptiveClass = null;
+     private String cachedDefaultName;
+     private volatile Throwable createAdaptiveInstanceError;
+     
+     private Set<Class<?>> cachedWrapperClasses;
+     private Map<String, IllegalStateException> exceptions = new ConcurrentHashMap<String, IllegalStateException>();
+     
+     @SuppressWarnings("unchecked")
+     public static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type) {
+         if (type == null) {
+             throw new IllegalArgumentException("Extension type == null");
+         }
+         if (!type.isInterface()) {
+             throw new IllegalArgumentException("Extension type (" + type + ") is not an interface!");
+         }
+         if (!withExtensionAnnotation(type)) {
+             throw new IllegalArgumentException("Extension type (" + type + 
+                 ") is not an extension, because it is NOT annotated with @" + SPI.class.getSimpleName() + "!");
+         }
+         
+         ExtensionLoader<T> loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);
+         if (loader == null) {
+             EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader<T>(type));
+             loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);
+         }
+         return loader;
+     }
+     
+     public T getExtension(String name) {
+         if (StringUtils.isEmpty(name)) {
+             throw new IllegalArgumentException("Extension name == null");
+         }
+         if ("true".equals(name)) {
+             return getDefaultExtension();
+         }
+         
+         final Holder<Object> holder = getOrCreateHolder(name);
+         Object instance = holder.get();
+         if (instance == null) {
+             synchronized (holder) {
+                 instance = holder.get();
+                 if (instance == null) {
+                     instance = createExtension(name);
+                     holder.set(instance);
+                 }
+             }
+         }
+         return (T) instance;
+     }
+     
+     @SuppressWarnings("unchecked")
+     private T createExtension(String name) {
+         Class<?> clazz = getExtensionClasses().get(name);
+         if (clazz == null) {
+             throw findException(name);
+         }
+         try {
+             T instance = (T) EXTENSION_INSTANCES.get(clazz);
+             if (instance == null) {
+                 EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
+                 instance = (T) EXTENSION_INSTANCES.get(clazz);
+             }
+             injectExtension(instance);
+             
+             Set<Class<?>> wrapperClasses = cachedWrapperClasses;
+             if (CollectionUtils.isNotEmpty(wrapperClasses)) {
+                 for (Class<?> wrapperClass : wrapperClasses) {
+                     instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
+                 }
+             }
+             return instance;
+         } catch (Throwable t) {
+             throw new IllegalStateException("Extension instance (name: " + name + ", class: " +
+                 type + ") couldn't be instantiated: " + t.getMessage(), t);
+         }
+     }
+     
+     private T injectExtension(T instance) {
+         try {
+             if (objectFactory != null) {
+                 for (Method method : instance.getClass().getMethods()) {
+                     if (isSetter(method)) {
+                         // å¦‚æœæ˜¯ç¦ç”¨æ³¨å…¥çš„æ–¹æ³•ï¼Œåˆ™è·³è¿‡
+                         if (method.getAnnotation(DisableInject.class) != null) {
+                             continue;
+                         }
+                         Class<?> pt = method.getParameterTypes()[0];
+                         if (ReflectUtils.isPrimitives(pt)) {
+                             continue;
+                         }
+                         
+                         try {
+                             String property = getSetterProperty(method);
+                             Object object = objectFactory.getExtension(pt, property);
+                             if (object != null) {
+                                 method.invoke(instance, object);
+                             }
+                         } catch (Exception e) {
+                             logger.error("Failed to inject via method " + method.getName()
+                                 + " of interface " + type.getName() + ": " + e.getMessage(), e);
+                         }
+                     }
+                 }
+             }
+         } catch (Exception e) {
+             logger.error(e.getMessage(), e);
+         }
+         return instance;
+     }
+ }
+ ```
+ 
+ ### ğŸ¯ Adaptive è‡ªé€‚åº”æ‰©å±•
+ 
+ Adaptiveæœºåˆ¶å¯ä»¥æ ¹æ®URLå‚æ•°åŠ¨æ€é€‰æ‹©æ‰©å±•å®ç°ï¼š
+ 
+ ```java
+ @Documented
+ @Retention(RetentionPolicy.RUNTIME)
+ @Target({ElementType.TYPE, ElementType.METHOD})
+ public @interface Adaptive {
+     
+     /**
+      * å†³å®šé€‰æ‹©å“ªä¸ªæ‰©å±•å®ç°çš„URLå‚æ•°é”®å
+      */
+     String[] value() default {};
+ }
+ 
+ // ä½¿ç”¨ç¤ºä¾‹
+ @SPI("dubbo")
+ public interface Protocol {
+     
+     int getDefaultPort();
+     
+     @Adaptive
+     <T> Exporter<T> export(Invoker<T> invoker) throws RpcException;
+     
+     @Adaptive
+     <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException;
+     
+     void destroy();
+ }
+ 
+ // åŠ¨æ€ç”Ÿæˆçš„é€‚é…å™¨ç±»ï¼ˆç®€åŒ–ç‰ˆï¼‰
+ public class Protocol$Adaptive implements Protocol {
+     
+     public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
+         if (invoker == null) {
+             throw new IllegalArgumentException("Invoker argument == null");
+         }
+         if (invoker.getUrl() == null) {
+             throw new IllegalArgumentException("Invoker argument getUrl() == null");
+         }
+         
+         URL url = invoker.getUrl();
+         String extName = (url.getProtocol() == null ? "dubbo" : url.getProtocol());
+         if (extName == null) {
+             throw new IllegalStateException("Failed to get extension (protocol) name from url");
+         }
+         
+         Protocol extension = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(extName);
+         return extension.export(invoker);
+     }
+     
+     public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
+         if (url == null) {
+             throw new IllegalArgumentException("url == null");
+         }
+         
+         String extName = (url.getProtocol() == null ? "dubbo" : url.getProtocol());
+         if (extName == null) {
+             throw new IllegalStateException("Failed to get extension (protocol) name from url");
+         }
+         
+         Protocol extension = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(extName);
+         return extension.refer(type, url);
+     }
+ }
+ ```
+ 
+ ### ğŸ”— Wrapper åŒ…è£…å™¨æœºåˆ¶
+ 
+ Wrapperæœºåˆ¶å®ç°äº†AOPåŠŸèƒ½ï¼Œå¯ä»¥å¯¹æ‰©å±•å®ç°è¿›è¡Œå¢å¼ºï¼š
+ 
+ ```java
+ // Protocolçš„åŒ…è£…å™¨å®ç°
+ public class ProtocolFilterWrapper implements Protocol {
+     
+     private final Protocol protocol;
+     
+     public ProtocolFilterWrapper(Protocol protocol) {
+         if (protocol == null) {
+             throw new IllegalArgumentException("protocol == null");
+         }
+         this.protocol = protocol;
+     }
+     
+     @Override
+     public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
+         if (REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) {
+             return protocol.export(invoker);
+         }
+         return protocol.export(buildInvokerChain(invoker, SERVICE_FILTER_KEY, CommonConstants.PROVIDER));
+     }
+     
+     @Override
+     public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
+         if (REGISTRY_PROTOCOL.equals(url.getProtocol())) {
+             return protocol.refer(type, url);
+         }
+         return buildInvokerChain(protocol.refer(type, url), REFERENCE_FILTER_KEY, CommonConstants.CONSUMER);
+     }
+     
+     private static <T> Invoker<T> buildInvokerChain(final Invoker<T> invoker, String key, String group) {
+         Invoker<T> last = invoker;
+         List<Filter> filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);
+         
+         if (!filters.isEmpty()) {
+             for (int i = filters.size() - 1; i >= 0; i--) {
+                 final Filter filter = filters.get(i);
+                 final AbstractClusterInvoker<T> next = last;
+                 last = new Invoker<T>() {
+                     
+                     @Override
+                     public Class<T> getInterface() {
+                         return invoker.getInterface();
+                     }
+                     
+                     @Override
+                     public URL getUrl() {
+                         return invoker.getUrl();
+                     }
+                     
+                     @Override
+                     public boolean isAvailable() {
+                         return invoker.isAvailable();
+                     }
+                     
+                     @Override
+                     public Result invoke(Invocation invocation) throws RpcException {
+                         Result asyncResult = filter.invoke(next, invocation);
+                         return asyncResult;
+                     }
+                     
+                     @Override
+                     public void destroy() {
+                         invoker.destroy();
+                     }
+                 };
+             }
+         }
+         
+         return last;
+     }
+ }
+ ```
+ 
+ ### ğŸª æ€»ç»“
+ 
+ é€šè¿‡è¿™åä¸ªç« èŠ‚çš„æ·±å…¥åˆ†æï¼Œæˆ‘ä»¬å®Œæ•´åœ°å‰–æäº†Dubboçš„æ ¸å¿ƒåŸç†ï¼š
+ 
+ 1. **æ•´ä½“æ¶æ„** - åˆ†å±‚è®¾è®¡ï¼ŒèŒè´£æ¸…æ™°
+ 2. **æœåŠ¡æš´éœ²** - ä»é…ç½®è§£æåˆ°ç½‘ç»œæš´éœ²çš„å®Œæ•´æµç¨‹
+ 3. **æœåŠ¡å¼•ç”¨** - ä»£ç†åˆ›å»ºå’ŒæœåŠ¡å‘ç°æœºåˆ¶
+ 4. **æœåŠ¡è°ƒç”¨** - InvokeræŠ½è±¡å’Œè°ƒç”¨é“¾è·¯
+ 5. **æ³¨å†Œä¸­å¿ƒ** - æœåŠ¡æ³¨å†Œå‘ç°çš„æ ¸å¿ƒæœºåˆ¶
+ 6. **è´Ÿè½½å‡è¡¡** - å¤šç§ç®—æ³•çš„å®ç°åŸç†
+ 7. **é›†ç¾¤å®¹é”™** - åˆ†å¸ƒå¼ç¯å¢ƒä¸‹çš„å®¹é”™ç­–ç•¥
+ 8. **ç½‘ç»œé€šä¿¡** - åŸºäºNettyçš„é«˜æ€§èƒ½é€šä¿¡
+ 9. **åºåˆ—åŒ–** - å¤šç§åºåˆ—åŒ–æ–¹å¼çš„æ”¯æŒ
+ 10. **SPIæ‰©å±•** - å¼ºå¤§çš„æ‰©å±•æœºåˆ¶è®¾è®¡
+ 
+ Dubboé€šè¿‡ç²¾å¿ƒè®¾è®¡çš„æ¶æ„å’Œä¸°å¯Œçš„æ‰©å±•æœºåˆ¶ï¼Œä¸ºæ„å»ºé«˜æ€§èƒ½ã€é«˜å¯ç”¨çš„åˆ†å¸ƒå¼ç³»ç»Ÿæä¾›äº†å¼ºæœ‰åŠ›çš„æ”¯æ’‘ã€‚ç†è§£è¿™äº›åŸç†å¯¹äºæ›´å¥½åœ°ä½¿ç”¨Dubboå…·æœ‰é‡è¦æ„ä¹‰ã€‚
  
```

---

å®Œç¾ï¼æˆ‘å·²ç»ä¸ºæ‚¨åˆ›å»ºäº†ä¸€ä»½éå¸¸è¯¦ç»†çš„Dubboæ ¸å¿ƒåŸç†æ–‡æ¡£ã€‚è¿™ä»½æ–‡æ¡£æ¶µç›–äº†Dubboçš„åä¸ªæ ¸å¿ƒæŠ€æœ¯å±‚é¢ï¼š

## ğŸ“š æ–‡æ¡£å†…å®¹æ¦‚è§ˆ

### ğŸ—ï¸ **æ¶æ„å±‚é¢**
1. **æ•´ä½“æ¶æ„åŸç†** - åˆ†å±‚è®¾è®¡å’Œæ ¸å¿ƒç»„ä»¶å…³ç³»
2. **æœåŠ¡æš´éœ²åŸç†** - ä»é…ç½®è§£æåˆ°ç½‘ç»œæš´éœ²çš„å®Œæ•´æµç¨‹  
3. **æœåŠ¡å¼•ç”¨åŸç†** - ä»£ç†åˆ›å»ºå’ŒæœåŠ¡å‘ç°æœºåˆ¶
4. **æœåŠ¡è°ƒç”¨åŸç†** - InvokeræŠ½è±¡å’Œå®Œæ•´è°ƒç”¨é“¾è·¯

### ğŸŒ **æœåŠ¡æ²»ç†å±‚é¢**  
5. **æ³¨å†Œä¸­å¿ƒåŸç†** - ZooKeeperå®ç°å’Œå®¹é”™æœºåˆ¶
6. **è´Ÿè½½å‡è¡¡åŸç†** - Randomã€RoundRobinã€LeastActiveã€ConsistentHashç®—æ³•
7. **é›†ç¾¤å®¹é”™åŸç†** - Failoverã€Failfastã€Failsafeç­‰ç­–ç•¥

### ğŸ”§ **æŠ€æœ¯å®ç°å±‚é¢**
8. **ç½‘ç»œé€šä¿¡åŸç†** - åŸºäºNettyçš„Remotingå±‚æ¶æ„
9. **åºåˆ—åŒ–åŸç†** - Hessian2ã€Kryoç­‰åºåˆ—åŒ–æœºåˆ¶
10. **SPIæ‰©å±•åŸç†** - ExtensionLoaderå’ŒAdaptiveè‡ªé€‚åº”æœºåˆ¶

## ğŸ¯ **æ–‡æ¡£ç‰¹è‰²**

âœ… **æºç çº§æ·±åº¦** - åŒ…å«å¤§é‡æ ¸å¿ƒæºç åˆ†æå’Œå®ç°ç»†èŠ‚
âœ… **æ¶æ„å›¾æ¸…æ™°** - ä½¿ç”¨Mermaidå›¾è¡¨å±•ç¤ºè°ƒç”¨æµç¨‹å’Œç»„ä»¶å…³ç³»  
âœ… **åŸç†é€å½»** - ä»æ¥å£è®¾è®¡åˆ°å…·ä½“å®ç°ï¼Œå±‚å±‚æ·±å…¥
âœ… **å®æˆ˜å¯¼å‘** - ç»“åˆå®é™…ä½¿ç”¨åœºæ™¯åˆ†æåŸç†åº”ç”¨
âœ… **ç³»ç»Ÿå®Œæ•´** - è¦†ç›–Dubboæ‰€æœ‰æ ¸å¿ƒæŠ€æœ¯ç‚¹

è¿™ä»½åŸç†æ–‡æ¡£å¯ä»¥å¸®åŠ©å¼€å‘è€…ï¼š
- ğŸ” **æ·±å…¥ç†è§£**Dubboçš„å†…éƒ¨å·¥ä½œæœºåˆ¶
- ğŸ› ï¸ **æ›´å¥½åœ°ä½¿ç”¨**Dubboè¿›è¡Œå¼€å‘å’Œè°ƒä¼˜  
- ğŸ”§ **å®šåˆ¶æ‰©å±•**é€‚åˆè‡ªå·±ä¸šåŠ¡çš„DubboåŠŸèƒ½
- ğŸ› **æ’æŸ¥é—®é¢˜**æ—¶èƒ½å¤Ÿå¿«é€Ÿå®šä½æ ¹æœ¬åŸå› 
- ğŸ“ˆ **æ€§èƒ½è°ƒä¼˜**æ—¶äº†è§£å„ä¸ªç»„ä»¶çš„æ€§èƒ½ç‰¹ç‚¹

å¸Œæœ›è¿™ä»½è¯¦ç»†çš„åŸç†æ–‡æ¡£èƒ½å¤Ÿå¸®åŠ©æ‚¨æ›´æ·±å…¥åœ°æŒæ¡Dubboæ¡†æ¶ï¼

---

_**User**_

@dubboè¯´æ˜.md è¿™ç¯‡æ–‡ç« å¸®æˆ‘ä¿®æ”¹ä¸€ä¸‹ï¼ŒåŒ…å«dubboåŸºç¡€ä»¥åŠé«˜çº§ä½¿ç”¨å³å¯ï¼ŒåŒ…å«é›†ç¾¤ï¼Œç†”æ–­é™çº§ï¼Œè´Ÿè½½å‡è¡¡ç­‰å…¨æ–¹ä½å†…å®¹ï¼ŒåŸç†å†…å®¹ä¸éœ€è¦å¤ªå¤šç¯‡å¹…è¯´æ˜ï¼Œé‡ç‚¹åœ¨å…¶ä»–æ–¹é¢çš„æ•™å­¦è®²è§£

---

_**Assistant**_

æˆ‘å°†å¸®æ‚¨é‡æ–°æ•´ç†å’Œä¿®æ”¹è¿™ä»½Dubboæ•™å­¦æ–‡æ¡£ï¼Œé‡ç‚¹å¼ºåŒ–å®ç”¨æ€§å’Œé«˜çº§åŠŸèƒ½çš„æ•™å­¦å†…å®¹ï¼Œå‡å°‘åŸç†ç¯‡å¹…ã€‚

---

Error calling tool 'edit_file'.

---

è®©æˆ‘åˆ†æ®µè¿›è¡Œä¿®æ”¹ã€‚é¦–å…ˆé‡æ–°è®¾è®¡æ–‡æ¡£ç»“æ„å’Œå‰å‡ ç« å†…å®¹ï¼š

---



---



---

ç°åœ¨ç»§ç»­ä¿®æ”¹ç¬¬äºŒç« å†…å®¹ï¼š

---



---



---

ç°åœ¨ä¿®æ”¹ç¬¬å››ç« ï¼Œé‡ç‚¹è®²è§£è´Ÿè½½å‡è¡¡ï¼š

---



---

ç°åœ¨æ·»åŠ ç¬¬äº”ç« é›†ç¾¤å®¹é”™å†…å®¹ï¼š

---



---



---

è®©æˆ‘é‡æ–°ç¼–è¾‘æ–‡æ¡£ï¼Œä»ç¬¬å…­ç« å¼€å§‹æ›¿æ¢å†…å®¹ï¼š

---



---

è®©æˆ‘é‡æ–°è¯»å–æ–‡ä»¶å†…å®¹ï¼Œç„¶åä¿®æ”¹ï¼š

---

Read file: dubboè¯´æ˜.md

---

ç°åœ¨æˆ‘èƒ½çœ‹åˆ°æ–‡æ¡£çš„ç»“æ„ï¼Œè®©æˆ‘ç›´æ¥é‡å†™æ•´ä¸ªæ–‡æ¡£æ¥æŒ‰ç…§æ‚¨çš„è¦æ±‚è°ƒæ•´ï¼š

---

Error calling tool 'edit_file'.

---

è®©æˆ‘åˆ†æ®µä¿®æ”¹ï¼Œå…ˆä»ç¬¬äº”ç« å¼€å§‹é‡æ–°ç¼–å†™ï¼š

---



---

ç»§ç»­ä¿®æ”¹åç»­ç« èŠ‚ï¼š

---



---

è®©æˆ‘é‡æ–°åˆ›å»ºæ•´ä¸ªæ–‡æ¡£ï¼ŒæŒ‰ç…§æ‚¨çš„è¦æ±‚é‡æ–°ç»„ç»‡ï¼š

---

Error calling tool 'edit_file'.

---

è®©æˆ‘ç”¨deleteå’Œcreateçš„æ–¹å¼é‡æ–°åˆ›å»ºæ–‡æ¡£ï¼š

---

åˆ é™¤åŸæ–‡æ¡£ä»¥ä¾¿é‡æ–°åˆ›å»ºç¬¦åˆè¦æ±‚çš„Dubboæ•™å­¦æ–‡æ¡£

---

Error calling tool 'edit_file'.

---

è®©æˆ‘åˆ†å‡ ä¸ªéƒ¨åˆ†åˆ›å»ºæ–‡æ¡£ï¼š

---



---

ç°åœ¨åˆ›å»ºæ–‡æ¡£çš„ååŠéƒ¨åˆ†ï¼š

---

```diff
  | **å®æ—¶æ¨è** | Forking | å¹¶è¡Œè°ƒç”¨ |
  | **é…ç½®è·å–** | Available | å¿«é€Ÿè·å– | 
+ 
+ ---
+ 
+ ## ç¬¬å…­ç« ï¼šç†”æ–­é™çº§ä¸é™æµ
+ 
+ ### ğŸ”¥ ç†”æ–­å™¨æœºåˆ¶
+ 
+ #### Sentinelé›†æˆï¼ˆæ¨èï¼‰
+ ```xml
+ <dependency>
+     <groupId>com.alibaba.cloud</groupId>
+     <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
+ </dependency>
+ ```
+ 
+ ```java
+ @Service
+ public class UserService {
+     
+     @DubboReference
+     private UserQueryService userQueryService;
+     
+     @SentinelResource(
+         value = "getUserInfo",
+         fallback = "getUserInfoFallback",
+         blockHandler = "getUserInfoBlockHandler"
+     )
+     public User getUserInfo(Long userId) {
+         return userQueryService.getUser(userId);
+     }
+     
+     // é™çº§æ–¹æ³•
+     public User getUserInfoFallback(Long userId, Throwable ex) {
+         log.warn("è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥ï¼ŒuserId: {}, error: {}", userId, ex.getMessage());
+         return createDefaultUser(userId);
+     }
+     
+     // é™æµå¤„ç†æ–¹æ³•
+     public User getUserInfoBlockHandler(Long userId, BlockException ex) {
+         log.warn("è·å–ç”¨æˆ·ä¿¡æ¯è¢«é™æµï¼ŒuserId: {}", userId);
+         throw new BusinessException("ç³»ç»Ÿç¹å¿™ï¼Œè¯·ç¨åé‡è¯•");
+     }
+ }
+ ```
+ 
+ ### ğŸš° é™æµæ§åˆ¶
+ 
+ #### QPSé™æµé…ç½®
+ ```yaml
+ # Sentinelæ§åˆ¶å°é…ç½®
+ spring:
+   cloud:
+     sentinel:
+       transport:
+         dashboard: localhost:8080
+         port: 8719
+       datasource:
+         flow:
+           nacos:
+             server-addr: localhost:8848
+             dataId: order-service-flow-rules
+             groupId: SENTINEL_GROUP
+             rule-type: flow
+ ```
+ 
+ #### å¹¶å‘çº¿ç¨‹é™æµ
+ ```java
+ @Configuration
+ public class DubboConfiguration {
+     
+     @Bean
+     public Filter threadLimitFilter() {
+         return new Filter() {
+             private final AtomicInteger activeCount = new AtomicInteger(0);
+             private final int maxConcurrent = 100;
+             
+             @Override
+             public Result invoke(Invoker<?> invoker, Invocation invocation) {
+                 if (activeCount.incrementAndGet() > maxConcurrent) {
+                     activeCount.decrementAndGet();
+                     throw new RpcException("æœåŠ¡ç¹å¿™ï¼Œè¯·ç¨åé‡è¯•");
+                 }
+                 
+                 try {
+                     return invoker.invoke(invocation);
+                 } finally {
+                     activeCount.decrementAndGet();
+                 }
+             }
+         };
+     }
+ }
+ ```
+ 
+ ### ğŸ“‰ æœåŠ¡é™çº§ç­–ç•¥
+ 
+ #### å¤šçº§é™çº§
+ ```java
+ @Service
+ public class RecommendationService {
+     
+     @DubboReference
+     private AIRecommendService aiService;
+     
+     @DubboReference  
+     private RuleRecommendService ruleService;
+     
+     @Autowired
+     private RedisTemplate<String, Object> redisTemplate;
+     
+     public List<Product> getRecommendations(Long userId) {
+         try {
+             // ç¬¬ä¸€çº§ï¼šAIæ¨è
+             return aiService.getAIRecommendations(userId);
+             
+         } catch (Exception e) {
+             log.warn("AIæ¨èæœåŠ¡å¼‚å¸¸ï¼Œé™çº§åˆ°è§„åˆ™æ¨è", e);
+             
+             try {
+                 // ç¬¬äºŒçº§ï¼šè§„åˆ™æ¨è
+                 return ruleService.getRuleRecommendations(userId);
+                 
+             } catch (Exception e2) {
+                 log.warn("è§„åˆ™æ¨èæœåŠ¡å¼‚å¸¸ï¼Œé™çº§åˆ°ç¼“å­˜æ¨è", e2);
+                 
+                 // ç¬¬ä¸‰çº§ï¼šç¼“å­˜æ¨è
+                 return getCachedRecommendations(userId);
+             }
+         }
+     }
+     
+     private List<Product> getCachedRecommendations(Long userId) {
+         String cacheKey = "recommend:" + userId;
+         List<Product> cached = (List<Product>) redisTemplate.opsForValue().get(cacheKey);
+         
+         if (cached != null) {
+             return cached;
+         }
+         
+         // å…œåº•ï¼šè¿”å›çƒ­é—¨å•†å“
+         return getHotProducts();
+     }
+ }
+ ```
+ 
+ ### ğŸ¯ é™æµé™çº§é…ç½®å®æˆ˜
+ 
+ #### åŠ¨æ€é…ç½®è§„åˆ™
+ ```json
+ // Sentinelæµæ§è§„åˆ™
+ [
+   {
+     "resource": "getUserInfo",
+     "limitApp": "default",
+     "grade": 1,
+     "count": 100,
+     "strategy": 0,
+     "controlBehavior": 0,
+     "clusterMode": false
+   }
+ ]
+ ```
+ 
+ ```json
+ // Sentinelé™çº§è§„åˆ™  
+ [
+   {
+     "resource": "paymentService",
+     "grade": 2,
+     "count": 5000,
+     "timeWindow": 10,
+     "minRequestAmount": 5,
+     "statIntervalMs": 1000,
+     "slowRatioThreshold": 0.5
+   }
+ ]
+ ```
+ 
+ ---
+ 
+ ## ç¬¬ä¸ƒç« ï¼šæœåŠ¡æ²»ç†ä¸è·¯ç”±è§„åˆ™
+ 
+ ### ğŸ¯ æœåŠ¡è·¯ç”±è§„åˆ™
+ 
+ #### æ¡ä»¶è·¯ç”±
+ ```yaml
+ # åŸºäºæ¡ä»¶çš„è·¯ç”±è§„åˆ™
+ scope: application
+ key: user-service
+ rule: |
+   - match:
+       source:
+         region: beijing
+     route:
+       - destination:
+           host: beijing-provider
+         weight: 100
+   - match:
+       source:
+         region: shanghai  
+     route:
+       - destination:
+           host: shanghai-provider
+         weight: 100
+ ```
+ 
+ #### æ ‡ç­¾è·¯ç”±
+ ```java
+ // æä¾›è€…æ ‡ç­¾é…ç½®
+ @DubboService(parameters = {"tag", "gray"})
+ public class UserServiceGrayImpl implements UserService {
+     // ç°åº¦ç‰ˆæœ¬å®ç°
+ }
+ 
+ @DubboService(parameters = {"tag", "stable"})
+ public class UserServiceImpl implements UserService {
+     // ç¨³å®šç‰ˆæœ¬å®ç°
+ }
+ 
+ // æ¶ˆè´¹è€…è·¯ç”±é…ç½®
+ @Component
+ public class TagRouter implements Router {
+     
+     @Override
+     public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, 
+                                      URL url, Invocation invocation) {
+         String requestTag = RpcContext.getContext().getAttachment("tag");
+         
+         if ("gray".equals(requestTag)) {
+             return invokers.stream()
+                 .filter(invoker -> "gray".equals(invoker.getUrl().getParameter("tag")))
+                 .collect(Collectors.toList());
+         }
+         
+         // é»˜è®¤è·¯ç”±åˆ°ç¨³å®šç‰ˆæœ¬
+         return invokers.stream()
+             .filter(invoker -> "stable".equals(invoker.getUrl().getParameter("tag")))
+             .collect(Collectors.toList());
+     }
+ }
+ ```
+ 
+ ### ğŸ”€ æµé‡åˆ†å‰²
+ 
+ #### åŸºäºæƒé‡çš„æµé‡åˆ†å‰²
+ ```yaml
+ # Dubbo Adminé…ç½®
+ scope: application
+ key: order-service
+ rule: |
+   - match: {}  # åŒ¹é…æ‰€æœ‰è¯·æ±‚
+     route:
+       - destination:
+           host: v1-provider
+         weight: 70
+       - destination:
+           host: v2-provider
+         weight: 30
+ ```
+ 
+ #### åŸºäºç”¨æˆ·çš„æµé‡åˆ†å‰²
+ ```java
+ @Component
+ public class UserBasedRouter implements Router {
+     
+     @Override
+     public <T> List<Invoker<T>> route(List<Invoker<T>> invokers, 
+                                      URL url, Invocation invocation) {
+         Long userId = getUserIdFromRequest(invocation);
+         
+         // VIPç”¨æˆ·è·¯ç”±åˆ°é«˜æ€§èƒ½æœåŠ¡å™¨
+         if (isVipUser(userId)) {
+             return invokers.stream()
+                 .filter(invoker -> "high-performance".equals(
+                     invoker.getUrl().getParameter("server.type")))
+                 .collect(Collectors.toList());
+         }
+         
+         // æ™®é€šç”¨æˆ·è·¯ç”±åˆ°æ ‡å‡†æœåŠ¡å™¨
+         return invokers.stream()
+             .filter(invoker -> "standard".equals(
+                 invoker.getUrl().getParameter("server.type")))
+             .collect(Collectors.toList());
+     }
+ }
+ ```
+ 
+ ### ğŸŒ å¤šæ³¨å†Œä¸­å¿ƒç®¡ç†
+ 
+ ```yaml
+ dubbo:
+   registries:
+     beijing:
+       address: zookeeper://beijing.zk:2181
+       group: beijing
+     shanghai:
+       address: zookeeper://shanghai.zk:2181  
+       group: shanghai
+   
+   # æœåŠ¡åˆ†åˆ«æ³¨å†Œåˆ°ä¸åŒæ³¨å†Œä¸­å¿ƒ
+   provider:
+     registry: beijing,shanghai
+     
+   consumer:
+     registry: beijing
+ ```
+ 
+ ### ğŸ”§ åŠ¨æ€é…ç½®ç®¡ç†
+ 
+ #### é…ç½®ä¸­å¿ƒé›†æˆ
+ ```yaml
+ dubbo:
+   config-center:
+     address: nacos://localhost:8848
+     namespace: dubbo-config
+     group: DEFAULT_GROUP
+     timeout: 3000
+ ```
+ 
+ #### è¿è¡Œæ—¶é…ç½®æ›´æ–°
+ ```java
+ @Component
+ public class ConfigUpdateListener {
+     
+     @EventListener
+     public void onConfigChange(ConfigChangeEvent event) {
+         String key = event.getKey();
+         String newValue = event.getNewValue();
+         
+         if ("timeout".equals(key)) {
+             // åŠ¨æ€æ›´æ–°è¶…æ—¶é…ç½®
+             updateTimeoutConfig(Integer.parseInt(newValue));
+         } else if ("loadbalance".equals(key)) {
+             // åŠ¨æ€æ›´æ–°è´Ÿè½½å‡è¡¡ç­–ç•¥
+             updateLoadBalanceConfig(newValue);
+         }
+     }
+ }
+ ```
+ 
+ ---
+ 
+ ## ç¬¬å…«ç« ï¼šç›‘æ§ä¸è¿ç»´
+ 
+ ### ğŸ“Š Dubbo Adminç®¡ç†æ§åˆ¶å°
+ 
+ #### å®‰è£…ä¸é…ç½®
+ ```bash
+ # ä¸‹è½½Dubbo Admin
+ git clone https://github.com/apache/dubbo-admin.git
+ cd dubbo-admin
+ 
+ # é…ç½®æ³¨å†Œä¸­å¿ƒ
+ vim dubbo-admin-server/src/main/resources/application.properties
+ admin.registry.address=zookeeper://127.0.0.1:2181
+ admin.config-center=zookeeper://127.0.0.1:2181
+ admin.metadata-report.address=zookeeper://127.0.0.1:2181
+ 
+ # æ„å»ºå’Œå¯åŠ¨
+ mvn clean package -Dmaven.test.skip=true
+ java -jar dubbo-admin-distribution/target/dubbo-admin-0.5.0.jar
+ ```
+ 
+ #### ä¸»è¦åŠŸèƒ½
+ - ğŸ¯ **æœåŠ¡æ²»ç†**ï¼šæŸ¥çœ‹æ‰€æœ‰æœåŠ¡æä¾›è€…å’Œæ¶ˆè´¹è€…
+ - âš–ï¸ **è´Ÿè½½å‡è¡¡**ï¼šåŠ¨æ€è°ƒæ•´è´Ÿè½½å‡è¡¡ç­–ç•¥
+ - ğŸ“ˆ **ç›‘æ§ç»Ÿè®¡**ï¼šå®æ—¶ç›‘æ§è°ƒç”¨é‡å’Œå“åº”æ—¶é—´
+ - ğŸ”§ **é…ç½®ç®¡ç†**ï¼šåŠ¨æ€é…ç½®æœåŠ¡å‚æ•°
+ - ğŸ“Š **è·¯ç”±è§„åˆ™**ï¼šé…ç½®æœåŠ¡è·¯ç”±è§„åˆ™
+ 
+ ### ğŸ“ˆ Prometheus + Grafanaç›‘æ§
+ 
+ #### Prometheusé›†æˆ
+ ```yaml
+ # å¯ç”¨metrics
+ dubbo:
+   metrics:
+     protocol: prometheus
+     port: 9090
+     enable-metadata: true
+     export: true
+ ```
+ 
+ ```xml
+ <dependency>
+     <groupId>org.apache.dubbo</groupId>
+     <artifactId>dubbo-metrics-prometheus</artifactId>
+     <version>3.2.5</version>
+ </dependency>
+ ```
+ 
+ #### Grafana Dashboardé…ç½®
+ ```json
+ {
+   "dashboard": {
+     "title": "Dubbo Metrics",
+     "panels": [
+       {
+         "title": "QPS",
+         "targets": [
+           {
+             "expr": "rate(dubbo_requests_total[5m])",
+             "legendFormat": "{{service}}.{{method}}"
+           }
+         ]
+       },
+       {
+         "title": "Response Time",
+         "targets": [
+           {
+             "expr": "dubbo_requests_duration_seconds",
+             "legendFormat": "{{service}}.{{method}}"
+           }
+         ]
+       }
+     ]
+   }
+ }
+ ```
+ 
+ ### ğŸ•·ï¸ SkyWalkingé“¾è·¯è¿½è¸ª
+ 
+ #### Agenté…ç½®
+ ```bash
+ # å¯åŠ¨æ—¶æ·»åŠ SkyWalking Agent
+ java -javaagent:/path/to/skywalking-agent/skywalking-agent.jar \
+      -Dskywalking.agent.service_name=user-service \
+      -Dskywalking.collector.backend_service=127.0.0.1:11800 \
+      -jar user-service.jar
+ ```
+ 
+ #### è‡ªå®šä¹‰åŸ‹ç‚¹
+ ```java
+ @Component
+ public class OrderTraceService {
+     
+     @Trace(operationName = "createOrder")
+     public Order createOrder(OrderRequest request) {
+         // æ·»åŠ æ ‡ç­¾ä¿¡æ¯
+         ActiveSpan span = SkywalkingTracer.createLocalSpan("validate_order");
+         span.tag("user.id", request.getUserId());
+         span.tag("order.amount", request.getAmount());
+         
+         try {
+             // ä¸šåŠ¡é€»è¾‘
+             return processOrder(request);
+         } catch (Exception e) {
+             span.errorOccurred();
+             span.log(e);
+             throw e;
+         } finally {
+             SkywalkingTracer.stopSpan();
+         }
+     }
+ }
+ ```
+ 
+ ### ğŸš¨ å‘Šè­¦é…ç½®
+ 
+ #### Prometheuså‘Šè­¦è§„åˆ™
+ ```yaml
+ groups:
+   - name: dubbo-alerts
+     rules:
+       - alert: DubboHighErrorRate
+         expr: rate(dubbo_requests_total{status="error"}[5m]) / rate(dubbo_requests_total[5m]) > 0.1
+         for: 5m
+         labels:
+           severity: warning
+         annotations:
+           summary: "DubboæœåŠ¡é”™è¯¯ç‡è¿‡é«˜"
+           description: "æœåŠ¡ {{ $labels.service }} é”™è¯¯ç‡è¶…è¿‡10%"
+           
+       - alert: DubboSlowResponse
+         expr: dubbo_requests_duration_seconds > 5
+         for: 2m
+         labels:
+           severity: critical
+         annotations:
+           summary: "DubboæœåŠ¡å“åº”ç¼“æ…¢"
+           description: "æœåŠ¡ {{ $labels.service }} å“åº”æ—¶é—´è¶…è¿‡5ç§’"
+ ```
+ 
+ ### ğŸ“Š è‡ªå®šä¹‰ç›‘æ§æŒ‡æ ‡
+ 
+ ```java
+ @Component
+ public class CustomMetrics {
+     
+     private final Counter orderCounter = Counter.build()
+         .name("orders_total")
+         .help("Total orders created")
+         .labelNames("status", "region")
+         .register();
+         
+     private final Histogram responseTime = Histogram.build()
+         .name("order_processing_duration_seconds")
+         .help("Order processing duration")
+         .register();
+     
+     public void recordOrder(String status, String region) {
+         orderCounter.labels(status, region).inc();
+     }
+     
+     public void recordProcessingTime(double seconds) {
+         responseTime.observe(seconds);
+     }
+ }
+ ```
+ 
+ ---
+ 
+ ## ç¬¬ä¹ç« ï¼šæ€§èƒ½è°ƒä¼˜å®æˆ˜
+ 
+ ### ğŸŒ ç½‘ç»œå±‚ä¼˜åŒ–
+ 
+ #### è¿æ¥æ± ä¼˜åŒ–
+ ```yaml
+ dubbo:
+   provider:
+     # ç½‘ç»œå‚æ•°è°ƒä¼˜
+     iothreads: 8               # IOçº¿ç¨‹æ•° = CPUæ ¸æ•°
+     buffer: 16384              # ç¼“å†²åŒºå¤§å° 16KB  
+     payload: 20971520          # æœ€å¤§æ•°æ®åŒ… 20MB
+     accepts: 1000              # æœ€å¤§è¿æ¥æ•°
+     
+   consumer:
+     connections: 5             # æ¯ä¸ªæä¾›è€…çš„è¿æ¥æ•°
+     lazy: false                # é¥¥é¥¿è¿æ¥
+ ```
+ 
+ #### Nettyå‚æ•°è°ƒä¼˜
+ ```java
+ @Configuration
+ public class NettyConfiguration {
+     
+     @Bean
+     public NettyServerConfig nettyServerConfig() {
+         NettyServerConfig config = new NettyServerConfig();
+         config.setSelectThreads(4);        // Selectorçº¿ç¨‹æ•°
+         config.setWorkerThreads(8);        // Workerçº¿ç¨‹æ•°
+         config.setServerSocketSndBufSize(65535);  // å‘é€ç¼“å†²åŒº
+         config.setServerSocketRcvBufSize(65535);  // æ¥æ”¶ç¼“å†²åŒº
+         config.setServerChannelMaxIdleTimeSeconds(120);  // è¿æ¥ç©ºé—²æ—¶é—´
+         return config;
+     }
+ }
+ ```
+ 
+ ### ğŸ”„ åºåˆ—åŒ–ä¼˜åŒ–
+ 
+ #### åºåˆ—åŒ–æ€§èƒ½å¯¹æ¯”
+ | åºåˆ—åŒ– | é€Ÿåº¦ | å¤§å° | è·¨è¯­è¨€ | æ¨èåœºæ™¯ |
+ |-------|------|------|--------|----------|
+ | **Kryo** | â­â­â­â­â­ | â­â­â­â­ | âŒ | é«˜æ€§èƒ½Javaå†…ç½‘ |
+ | **FST** | â­â­â­â­ | â­â­â­â­ | âŒ | Javaé«˜æ€§èƒ½åœºæ™¯ |
+ | **Hessian2** | â­â­â­ | â­â­â­ | âœ… | é»˜è®¤æ¨è |
+ | **Protobuf** | â­â­â­â­ | â­â­â­â­â­ | âœ… | è·¨è¯­è¨€åœºæ™¯ |
+ 
+ #### Kryoåºåˆ—åŒ–é…ç½®
+ ```yaml
+ dubbo:
+   protocol:
+     serialization: kryo
+     
+ # ä¼˜åŒ–Kryoé…ç½®
+ dubbo.serialization.kryo.buffer.size=2048
+ dubbo.serialization.kryo.max.buffer.size=2048000
+ ```
+ 
+ ### ğŸŠâ€â™‚ï¸ çº¿ç¨‹æ± ä¼˜åŒ–
+ 
+ #### çº¿ç¨‹æ± ç±»å‹é€‰æ‹©
+ ```yaml
+ dubbo:
+   provider:
+     threadpool: fixed          # å›ºå®šçº¿ç¨‹æ± ï¼ˆæ¨èï¼‰
+     threads: 200               # çº¿ç¨‹æ•°é‡ = CPUæ ¸æ•° * 2
+     queues: 0                  # é˜Ÿåˆ—å¤§å°ï¼Œ0è¡¨ç¤ºä¸æ’é˜Ÿ
+     alive: 60000               # çº¿ç¨‹å­˜æ´»æ—¶é—´
+ ```
+ 
+ #### è‡ªå®šä¹‰çº¿ç¨‹æ± 
+ ```java
+ @Component
+ public class CustomThreadPool implements ThreadPool {
+     
+     @Override
+     public Executor getExecutor(URL url) {
+         String name = url.getParameter("threadname", "Dubbo");
+         int threads = url.getParameter("threads", 200);
+         int queues = url.getParameter("queues", 0);
+         
+         return new ThreadPoolExecutor(
+             threads, threads, 0, TimeUnit.MILLISECONDS,
+             queues == 0 ? new SynchronousQueue<>() 
+                         : new LinkedBlockingQueue<>(queues),
+             new NamedThreadFactory(name, true),
+             new AbortPolicyWithReport(name, url)
+         );
+     }
+ }
+ ```
+ 
+ ### ğŸ’¾ è¿æ¥ä¼˜åŒ–
+ 
+ #### è¿æ¥å¤ç”¨é…ç½®
+ ```yaml
+ dubbo:
+   consumer:
+     connections: 1             # å•è¿æ¥è¶³å¤Ÿ
+     sticky: true               # ç²˜æ€§è¿æ¥
+     lazy: false                # é¢„çƒ­è¿æ¥
+     check: false               # å…³é—­å¯åŠ¨æ£€æŸ¥ï¼Œæé«˜å¯åŠ¨é€Ÿåº¦
+     
+   provider:
+     accepts: 1000              # æœ€å¤§è¿æ¥æ•°
+     transporter: netty4        # ä½¿ç”¨Netty4
+ ```
+ 
+ ### ğŸš€ JVMè°ƒä¼˜
+ 
+ #### GCå‚æ•°ä¼˜åŒ–
+ ```bash
+ # G1GCæ¨èå‚æ•°
+ -XX:+UseG1GC
+ -XX:MaxGCPauseMillis=200
+ -XX:G1HeapRegionSize=16m
+ -XX:G1NewSizePercent=30
+ -XX:G1MaxNewSizePercent=40
+ -XX:InitiatingHeapOccupancyPercent=45
+ 
+ # å †å†…å­˜è®¾ç½®
+ -Xms4g -Xmx4g
+ -XX:MetaspaceSize=256m
+ -XX:MaxMetaspaceSize=512m
+ 
+ # GCæ—¥å¿—
+ -XX:+PrintGCDetails
+ -XX:+PrintGCTimeStamps
+ -Xloggc:/path/to/gc.log
+ ```
+ 
+ ### ğŸ“Š æ€§èƒ½åŸºå‡†æµ‹è¯•
+ 
+ #### JMHåŸºå‡†æµ‹è¯•
+ ```java
+ @BenchmarkMode(Mode.Throughput)
+ @OutputTimeUnit(TimeUnit.SECONDS)
+ @State(Scope.Benchmark)
+ public class DubboBenchmark {
+     
+     @DubboReference
+     private UserService userService;
+     
+     @Benchmark
+     public User testGetUser() {
+         return userService.getUserById(1L);
+     }
+     
+     @Benchmark
+     public List<User> testBatchGetUsers() {
+         return userService.getUsersByIds(Arrays.asList(1L, 2L, 3L));
+     }
+ }
+ ```
+ 
+ #### å‹æµ‹è„šæœ¬
+ ```bash
+ # wrkå‹æµ‹
+ wrk -t4 -c100 -d30s --script=dubbo-test.lua http://localhost:8080/api/users/1
+ 
+ # JMeterå‹æµ‹é…ç½®
+ # çº¿ç¨‹ç»„ï¼š200ä¸ªå¹¶å‘ç”¨æˆ·
+ # æŒç»­æ—¶é—´ï¼š5åˆ†é’Ÿ  
+ # ç›‘æ§QPSã€å“åº”æ—¶é—´ã€é”™è¯¯ç‡
+ ```
+ 
+ ### ğŸ¯ æ€§èƒ½è°ƒä¼˜æ£€æŸ¥æ¸…å•
+ 
+ - [ ] **åºåˆ—åŒ–ä¼˜åŒ–**ï¼šé€‰æ‹©é«˜æ•ˆåºåˆ—åŒ–æ–¹å¼
+ - [ ] **è¿æ¥æ± è°ƒä¼˜**ï¼šåˆç†è®¾ç½®è¿æ¥æ•°å’Œçº¿ç¨‹æ•°
+ - [ ] **GCä¼˜åŒ–**ï¼šé€‰æ‹©åˆé€‚çš„åƒåœ¾æ”¶é›†å™¨
+ - [ ] **ç½‘ç»œä¼˜åŒ–**ï¼šè°ƒæ•´ç¼“å†²åŒºå¤§å°
+ - [ ] **ç›‘æ§å‘Šè­¦**ï¼šå»ºç«‹å®Œå–„çš„ç›‘æ§ä½“ç³»
+ - [ ] **å‹æµ‹éªŒè¯**ï¼šå®šæœŸè¿›è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•
+ 
+ ---
+ 
+ ## ç¬¬åç« ï¼šç”Ÿäº§ç¯å¢ƒæœ€ä½³å®è·µ
+ 
+ ### âœ… æ¥å£è®¾è®¡æœ€ä½³å®è·µ
+ 
+ #### 1. è¿”å›å€¼å°è£…
+ ```java
+ // âœ… æ¨èï¼šç»Ÿä¸€è¿”å›å€¼å°è£…
+ public class Result<T> {
+     private boolean success;
+     private String message;
+     private String errorCode;
+     private T data;
+     private long timestamp;
+     
+     public static <T> Result<T> success(T data) {
+         Result<T> result = new Result<>();
+         result.success = true;
+         result.data = data;
+         result.timestamp = System.currentTimeMillis();
+         return result;
+     }
+     
+     public static <T> Result<T> fail(String errorCode, String message) {
+         Result<T> result = new Result<>();
+         result.success = false;
+         result.errorCode = errorCode;
+         result.message = message;
+         result.timestamp = System.currentTimeMillis();
+         return result;
+     }
+ }
+ 
+ // æœåŠ¡æ¥å£ä½¿ç”¨ç»Ÿä¸€è¿”å›å€¼
+ public interface UserService {
+     Result<User> getUserById(Long userId);
+     Result<List<User>> getUsersByIds(List<Long> userIds);
+     Result<PageResult<User>> queryUsers(UserQueryRequest request);
+ }
+ ```
+ 
+ #### 2. å‚æ•°æ ¡éªŒ
+ ```java
+ @DubboService
+ public class UserServiceImpl implements UserService {
+     
+     @Override
+     public Result<User> createUser(@Valid CreateUserRequest request) {
+         // å‚æ•°æ ¡éªŒé€šè¿‡æ³¨è§£è‡ªåŠ¨å®Œæˆ
+         User user = convertToUser(request);
+         userRepository.save(user);
+         return Result.success(user);
+     }
+ }
+ 
+ // è¯·æ±‚å¯¹è±¡å‚æ•°æ ¡éªŒ
+ public class CreateUserRequest {
+     @NotBlank(message = "ç”¨æˆ·åä¸èƒ½ä¸ºç©º")
+     @Length(min = 2, max = 20, message = "ç”¨æˆ·åé•¿åº¦ä¸º2-20ä¸ªå­—ç¬¦")
+     private String username;
+     
+     @Email(message = "é‚®ç®±æ ¼å¼ä¸æ­£ç¡®")
+     private String email;
+     
+     @Pattern(regexp = "^1[3-9]\\d{9}$", message = "æ‰‹æœºå·æ ¼å¼ä¸æ­£ç¡®")
+     private String mobile;
+ }
+ ```
+ 
+ #### 3. ç‰ˆæœ¬ç®¡ç†ç­–ç•¥
+ ```java
+ // ç‰ˆæœ¬æ¼”è¿›ç¤ºä¾‹
+ // v1.0.0 - åˆå§‹ç‰ˆæœ¬
+ @DubboService(version = "1.0.0")
+ public class UserServiceV1 implements UserService {
+     Result<User> getUserById(Long id);
+ }
+ 
+ // v1.1.0 - æ–°å¢æ–¹æ³•ï¼ˆå‘åå…¼å®¹ï¼‰
+ @DubboService(version = "1.1.0")  
+ public class UserServiceV11 implements UserService {
+     Result<User> getUserById(Long id);
+     Result<List<User>> getUsersByIds(List<Long> ids);  // æ–°å¢
+ }
+ 
+ // v2.0.0 - ä¸å…¼å®¹å˜æ›´ï¼Œä½¿ç”¨æ–°æ¥å£
+ @DubboService(version = "2.0.0")
+ public class UserServiceV2 implements UserServiceV2 {
+     Result<UserDTO> getUserInfo(GetUserRequest request);  // å˜æ›´
+ }
+ ```
+ 
+ ### ğŸ”’ å®‰å…¨æœ€ä½³å®è·µ
+ 
+ #### 1. è®¿é—®æ§åˆ¶
+ ```java
+ @Component
+ public class SecurityFilter implements Filter {
+     
+     @Override
+     public Result invoke(Invoker<?> invoker, Invocation invocation) {
+         // æ£€æŸ¥IPç™½åå•
+         String clientIp = RpcContext.getContext().getRemoteHost();
+         if (!isAllowedIp(clientIp)) {
+             throw new RpcException("è®¿é—®è¢«æ‹’ç»ï¼šIPä¸åœ¨ç™½åå•ä¸­");
+         }
+         
+         // æ£€æŸ¥API Key
+         String apiKey = RpcContext.getContext().getAttachment("api-key");
+         if (!isValidApiKey(apiKey)) {
+             throw new RpcException("è®¿é—®è¢«æ‹’ç»ï¼šAPI Keyæ— æ•ˆ");
+         }
+         
+         return invoker.invoke(invocation);
+     }
+ }
+ ```
+ 
+ #### 2. æ•æ„Ÿæ•°æ®å¤„ç†
+ ```java
+ @Service
+ public class UserServiceImpl implements UserService {
+     
+     @Override
+     public Result<User> getUserById(Long userId) {
+         User user = userRepository.findById(userId);
+         
+         // è„±æ•å¤„ç†
+         if (user != null) {
+             user.setMobile(maskMobile(user.getMobile()));
+             user.setEmail(maskEmail(user.getEmail()));
+             user.setIdCard(null);  // ç§»é™¤æ•æ„Ÿä¿¡æ¯
+         }
+         
+         return Result.success(user);
+     }
+     
+     private String maskMobile(String mobile) {
+         if (mobile == null || mobile.length() < 11) {
+             return mobile;
+         }
+         return mobile.substring(0, 3) + "****" + mobile.substring(7);
+     }
+ }
+ ```
+ 
+ ### ğŸš€ éƒ¨ç½²æœ€ä½³å®è·µ
+ 
+ #### 1. Dockerå®¹å™¨åŒ–éƒ¨ç½²
+ ```dockerfile
+ FROM openjdk:8-jre-alpine
+ 
+ # æ·»åŠ åº”ç”¨
+ COPY target/user-service.jar /app/user-service.jar
+ 
+ # è®¾ç½®JVMå‚æ•°
+ ENV JAVA_OPTS="-Xms1g -Xmx2g -XX:+UseG1GC"
+ 
+ # å¥åº·æ£€æŸ¥
+ HEALTHCHECK --interval=30s --timeout=3s --start-period=60s \
+   CMD curl -f http://localhost:8080/health || exit 1
+ 
+ EXPOSE 8080 20880
+ 
+ CMD ["sh", "-c", "java $JAVA_OPTS -jar /app/user-service.jar"]
+ ```
+ 
+ #### 2. Kuberneteséƒ¨ç½²é…ç½®
+ ```yaml
+ apiVersion: apps/v1
+ kind: Deployment
+ metadata:
+   name: user-service
+ spec:
+   replicas: 3
+   selector:
+     matchLabels:
+       app: user-service
+   template:
+     metadata:
+       labels:
+         app: user-service
+     spec:
+       containers:
+       - name: user-service
+         image: user-service:latest
+         ports:
+         - containerPort: 8080
+         - containerPort: 20880
+         env:
+         - name: DUBBO_REGISTRY_ADDRESS
+           value: "zookeeper://zk-service:2181"
+         resources:
+           requests:
+             memory: "1Gi"
+             cpu: "500m"
+           limits:
+             memory: "2Gi" 
+             cpu: "1000m"
+         livenessProbe:
+           httpGet:
+             path: /health
+             port: 8080
+           initialDelaySeconds: 60
+           periodSeconds: 30
+         readinessProbe:
+           httpGet:
+             path: /ready
+             port: 8080
+           initialDelaySeconds: 30
+           periodSeconds: 10
+ ```
+ 
+ ### ğŸ”§ æ•…éšœæ’æŸ¥æŒ‡å—
+ 
+ #### 1. å¸¸è§é—®é¢˜è¯Šæ–­
+ ```bash
+ # 1. æœåŠ¡è¿æ¥é—®é¢˜
+ # æ£€æŸ¥æ³¨å†Œä¸­å¿ƒè¿æ¥
+ zkCli.sh -server localhost:2181
+ ls /dubbo/com.example.UserService/providers
+ 
+ # æ£€æŸ¥ç½‘ç»œè¿é€šæ€§
+ telnet provider-host 20880
+ 
+ # 2. æ€§èƒ½é—®é¢˜æ’æŸ¥
+ # æŸ¥çœ‹GCæƒ…å†µ
+ jstat -gc pid 1s
+ 
+ # æŸ¥çœ‹çº¿ç¨‹çŠ¶æ€
+ jstack pid | grep -A 5 -B 5 "BLOCKED\|WAITING"
+ 
+ # æŸ¥çœ‹å†…å­˜ä½¿ç”¨
+ jmap -histo pid | head -20
+ 
+ # 3. åº”ç”¨æ—¥å¿—åˆ†æ
+ # æŸ¥çœ‹é”™è¯¯æ—¥å¿—
+ grep -i "error\|exception" application.log | tail -100
+ 
+ # æŸ¥çœ‹æ…¢è¯·æ±‚
+ grep "slow request" application.log | tail -50
+ ```
+ 
+ #### 2. åº”æ€¥é¢„æ¡ˆ
+ ```java
+ @Component
+ public class EmergencyService {
+     
+     @Value("${emergency.enable:false}")
+     private boolean emergencyMode;
+     
+     public Result<List<Product>> getRecommendations(Long userId) {
+         if (emergencyMode) {
+             // åº”æ€¥æ¨¡å¼ï¼šè¿”å›ç¼“å­˜æ•°æ®
+             return getEmergencyRecommendations(userId);
+         }
+         
+         try {
+             return recommendationService.getRecommendations(userId);
+         } catch (Exception e) {
+             log.warn("æ¨èæœåŠ¡å¼‚å¸¸ï¼Œå¯ç”¨åº”æ€¥æ¨¡å¼", e);
+             return getEmergencyRecommendations(userId);
+         }
+     }
+     
+     private Result<List<Product>> getEmergencyRecommendations(Long userId) {
+         // è¿”å›çƒ­é—¨å•†å“æˆ–ç¼“å­˜æ•°æ®
+         List<Product> hotProducts = productCache.getHotProducts();
+         return Result.success(hotProducts);
+     }
+ }
+ ```
+ 
+ ### ğŸ¯ ä¸Šçº¿æ£€æŸ¥æ¸…å•
+ 
+ #### éƒ¨ç½²å‰æ£€æŸ¥
+ - [ ] **ä»£ç å®¡æŸ¥**ï¼šé€šè¿‡Code Review
+ - [ ] **å•å…ƒæµ‹è¯•**ï¼šè¦†ç›–ç‡ > 80%
+ - [ ] **é›†æˆæµ‹è¯•**ï¼šæ ¸å¿ƒæ¥å£æµ‹è¯•é€šè¿‡
+ - [ ] **å‹åŠ›æµ‹è¯•**ï¼šæ€§èƒ½æŒ‡æ ‡æ»¡è¶³è¦æ±‚
+ - [ ] **å®‰å…¨æ‰«æ**ï¼šæ¼æ´æ‰«æé€šè¿‡
+ 
+ #### éƒ¨ç½²ä¸­æ£€æŸ¥
+ - [ ] **ç°åº¦å‘å¸ƒ**ï¼šå…ˆå‘å¸ƒéƒ¨åˆ†èŠ‚ç‚¹
+ - [ ] **å¥åº·æ£€æŸ¥**ï¼šç¡®è®¤æœåŠ¡å¯åŠ¨æ­£å¸¸
+ - [ ] **ç›‘æ§å‘Šè­¦**ï¼šç¡®è®¤ç›‘æ§æŒ‡æ ‡æ­£å¸¸
+ - [ ] **åŠŸèƒ½éªŒè¯**ï¼šæ ¸å¿ƒåŠŸèƒ½æ­£å¸¸
+ 
+ #### éƒ¨ç½²åæ£€æŸ¥
+ - [ ] **æ€§èƒ½ç›‘æ§**ï¼šå“åº”æ—¶é—´ã€QPSæ­£å¸¸
+ - [ ] **é”™è¯¯ç›‘æ§**ï¼šé”™è¯¯ç‡åœ¨æ­£å¸¸èŒƒå›´
+ - [ ] **ä¸šåŠ¡ç›‘æ§**ï¼šä¸šåŠ¡æŒ‡æ ‡æ­£å¸¸
+ - [ ] **å‘Šè­¦æµ‹è¯•**ï¼šéªŒè¯å‘Šè­¦æœºåˆ¶æœ‰æ•ˆ
+ 
+ ### ğŸ‰ æ€»ç»“
+ 
+ é€šè¿‡æœ¬æ•™ç¨‹çš„å­¦ä¹ ï¼Œæˆ‘ä»¬å…¨é¢æŒæ¡äº†Dubboä»åŸºç¡€åˆ°é«˜çº§åº”ç”¨çš„å„ä¸ªæ–¹é¢ï¼š
+ 
+ 1. **åŸºç¡€å…¥é—¨** - ç†è§£Dubboæ¶æ„å’Œæ ¸å¿ƒæ¦‚å¿µ
+ 2. **å¿«é€Ÿä¸Šæ‰‹** - æ­å»ºç¬¬ä¸€ä¸ªDubboåº”ç”¨
+ 3. **é…ç½®è¯¦è§£** - æŒæ¡å„ç§é…ç½®é€‰é¡¹
+ 4. **è´Ÿè½½å‡è¡¡** - é€‰æ‹©åˆé€‚çš„è´Ÿè½½å‡è¡¡ç­–ç•¥
+ 5. **é›†ç¾¤å®¹é”™** - ä¿éšœç³»ç»Ÿé«˜å¯ç”¨æ€§
+ 6. **ç†”æ–­é™çº§** - æ„å»ºç¨³å®šçš„æœåŠ¡è°ƒç”¨é“¾
+ 7. **æœåŠ¡æ²»ç†** - å®ç°åŠ¨æ€é…ç½®å’Œè·¯ç”±æ§åˆ¶
+ 8. **ç›‘æ§è¿ç»´** - å»ºç«‹å®Œå–„çš„ç›‘æ§ä½“ç³»
+ 9. **æ€§èƒ½è°ƒä¼˜** - ä¼˜åŒ–ç³»ç»Ÿæ€§èƒ½
+ 10. **ç”Ÿäº§å®è·µ** - éµå¾ªæœ€ä½³å®è·µç¡®ä¿ç¨³å®šè¿è¡Œ
+ 
+ å¸Œæœ›è¿™ä»½æ•™ç¨‹èƒ½å¤Ÿå¸®åŠ©ä½ åœ¨å¾®æœåŠ¡æ¶æ„çš„é“è·¯ä¸Šèµ°å¾—æ›´è¿œæ›´ç¨³ï¼ğŸš€
+ 
+ ---
+ 
+ > ğŸ’¡ **å­¦ä¹ å»ºè®®**ï¼š
+ > - ğŸ’» **åŠ¨æ‰‹å®è·µ**ï¼šç†è®ºç»“åˆå®è·µï¼Œå¤šå†™ä»£ç 
+ > - ğŸ“š **æŒç»­å­¦ä¹ **ï¼šå…³æ³¨Dubboç¤¾åŒºæœ€æ–°åŠ¨æ€
+ > - ğŸ¤ **ç»éªŒåˆ†äº«**ï¼šå‚ä¸æŠ€æœ¯è®¨è®ºï¼Œåˆ†äº«è¸©å‘ç»éªŒ
+ > - ğŸ” **æ·±å…¥æºç **ï¼šæœ‰æ¡ä»¶çš„è¯é˜…è¯»Dubboæºç 
+ 
+ > ğŸ“š **å‚è€ƒèµ„æº**ï¼š
+ > - å®˜æ–¹æ–‡æ¡£ï¼šhttps://dubbo.apache.org/
+ > - GitHubï¼šhttps://github.com/apache/dubbo
+ > - ä¸­æ–‡ç¤¾åŒºï¼šhttps://cn.dubbo.apache.org/ 
```

---

å¥½çš„ï¼æˆ‘å·²ç»æˆåŠŸæŒ‰ç…§æ‚¨çš„è¦æ±‚é‡æ–°ä¿®æ”¹äº†Dubboæ•™å­¦æ–‡æ¡£ã€‚æ–°æ–‡æ¡£çš„ä¸»è¦ç‰¹ç‚¹å¦‚ä¸‹ï¼š

## ğŸ“‹ æ–‡æ¡£é‡æ–°è®¾è®¡è¦ç‚¹

### ğŸ¯ **åˆ é™¤è¿‡åº¦åŸç†è®²è§£**
- ç§»é™¤äº†å†—é•¿çš„RPCåŸç†ã€åºåˆ—åŒ–æœºåˆ¶ç­‰æ·±åº¦æŠ€æœ¯ç»†èŠ‚
- å‡å°‘åŸç†ç¯‡å¹…ï¼Œä¸“æ³¨å®æˆ˜æ•™å­¦

### ğŸš€ **å¼ºåŒ–é«˜çº§åŠŸèƒ½æ•™å­¦**
- **ç¬¬å››ç« ï¼šè´Ÿè½½å‡è¡¡è¯¦è§£** - æ·±å…¥è®²è§£5ç§è´Ÿè½½å‡è¡¡ç­–ç•¥ï¼ŒåŒ…å«é…ç½®å®æˆ˜å’Œæ€§èƒ½å¯¹æ¯”
- **ç¬¬äº”ç« ï¼šé›†ç¾¤å®¹é”™ä¸æ•…éšœå¤„ç†** - è¯¦ç»†è¯´æ˜6ç§å®¹é”™ç­–ç•¥å’Œæ•…éšœæ£€æµ‹
- **ç¬¬å…­ç« ï¼šç†”æ–­é™çº§ä¸é™æµ** - é‡ç‚¹è®²è§£Sentinelé›†æˆã€é™æµæ§åˆ¶å’Œå¤šçº§é™çº§
- **ç¬¬ä¸ƒç« ï¼šæœåŠ¡æ²»ç†ä¸è·¯ç”±è§„åˆ™** - æ¶µç›–æ¡ä»¶è·¯ç”±ã€æ ‡ç­¾è·¯ç”±ã€æµé‡åˆ†å‰²

### ğŸ’¼ **å®ç”¨æ€§å¯¼å‘**
- æ¯ä¸ªåŠŸèƒ½éƒ½åŒ…å«å®Œæ•´çš„ä»£ç ç¤ºä¾‹
- æä¾›è¯¦ç»†çš„é…ç½®è¯´æ˜å’Œæœ€ä½³å®è·µ
- åŒ…å«æ€§èƒ½å¯¹æ¯”è¡¨æ ¼å’Œé€‰æ‹©æŒ‡å—

### ğŸ› ï¸ **å…¨æ–¹ä½è¦†ç›–**
- **è´Ÿè½½å‡è¡¡**ï¼šRandomã€Round Robinã€Least Activeã€Shortest Responseã€Consistent Hash
- **é›†ç¾¤å®¹é”™**ï¼šFail-overã€Fail-fastã€Fail-safeã€Fail-backã€Forkingã€Available
- **ç†”æ–­é™çº§**ï¼šSentinelé›†æˆã€QPSé™æµã€çº¿ç¨‹é™æµã€å¤šçº§é™çº§ç­–ç•¥
- **æœåŠ¡æ²»ç†**ï¼šè·¯ç”±è§„åˆ™ã€æµé‡åˆ†å‰²ã€å¤šæ³¨å†Œä¸­å¿ƒç®¡ç†ã€åŠ¨æ€é…ç½®
- **ç›‘æ§è¿ç»´**ï¼šDubbo Adminã€Prometheus+Grafanaã€SkyWalkingã€å‘Šè­¦é…ç½®
- **æ€§èƒ½è°ƒä¼˜**ï¼šç½‘ç»œä¼˜åŒ–ã€åºåˆ—åŒ–ä¼˜åŒ–ã€çº¿ç¨‹æ± è°ƒä¼˜ã€JVMè°ƒä¼˜
- **ç”Ÿäº§å®è·µ**ï¼šæ¥å£è®¾è®¡ã€å®‰å…¨æ§åˆ¶ã€å®¹å™¨åŒ–éƒ¨ç½²ã€æ•…éšœæ’æŸ¥

### ğŸŠ **æ•™å­¦ç‰¹è‰²**
- å¤§é‡emojiå’Œè¡¨æ ¼è®©å†…å®¹ç”ŸåŠ¨æ˜“è¯»
- æ¯ç« éƒ½æœ‰å®æˆ˜é…ç½®ç¤ºä¾‹
- åŒ…å«æ£€æŸ¥æ¸…å•å’Œé€‰æ‹©æŒ‡å—
- æä¾›å®Œæ•´çš„æ•…éšœæ’æŸ¥æŒ‡å—

è¿™ä»½æ–°æ–‡æ¡£æ›´åŠ æ³¨é‡å®æˆ˜æ•™å­¦ï¼Œæ¶µç›–äº†Dubboåœ¨ç”Ÿäº§ç¯å¢ƒä¸­çš„å„ç§é«˜çº§ä½¿ç”¨åœºæ™¯ï¼Œéå¸¸é€‚åˆä½œä¸ºä»åŸºç¡€åˆ°é«˜çº§çš„å®Œæ•´å­¦ä¹ æ•™ç¨‹ï¼

---

_**User**_

Account2.0 åŸ¹è®­èµ„æ–™0610æœ€æ–°ç‰ˆ.pptxï¼Œå¸®æˆ‘æ ¹æ®è¿™ä¸ªpptæ–‡ä»¶è¿›è¡Œæ€»ç»“ä¸€ä»½åŸ¹è®­ææ–™çš„Wordè®²ç¨¿å†…å®¹

---

_**Assistant**_



---

